{
    "version": "https://jsonfeed.org/version/1",
    "title": "Finecloud",
    "description": "",
    "home_page_url": "https://www.finecloud.ch",
    "feed_url": "https://www.finecloud.ch/feed.json",
    "user_comment": "",
    "icon": "https://www.finecloud.ch/media/website/cloud.png",
    "author": {
        "name": "Finecloud"
    },
    "items": [
        {
            "id": "https://www.finecloud.ch/lambda-funktionale-interfaces.html",
            "url": "https://www.finecloud.ch/lambda-funktionale-interfaces.html",
            "title": "Lambda Funktionale Interfaces",
            "summary": "Lambda Interfaces sind häufig benötigte Lambda-Ausdrücke, die Teil des JDKs sind und damit nicht in jedem Projekt wieder neu angelegt werden müssen. Zum Beispiel kann mit dieser Methode eine Summe aus Objekten berechnet werden: public static &lt;T&gt; long summiere(List&lt;T&gt; tees, ToIntFunction&lt;T&gt; func){ long result =&hellip;",
            "content_html": "<p>Lambda Interfaces sind häufig benötigte Lambda-Ausdrücke, die Teil des JDKs sind und damit nicht in jedem Projekt wieder neu angelegt werden müssen.</p>\n<p>Zum Beispiel kann mit dieser Methode eine Summe aus Objekten berechnet werden:</p>\n<p><code>public static &lt;T&gt; long summiere(List&lt;T&gt; tees, ToIntFunction&lt;T&gt; func){</code><br><code>    long result = 0;</code><br><code>    for (T tee : tees){</code><br><code>        result += func.applyAsInt(tee);</code><br><code>    }</code><br><code>    return result;</code><br><code>}</code></p>\n<p>Alle Interfaces die Lambda-Ausdrücke ermöglichen, sind Bestandteil des Packages java.util.function. Darin sind rund 40 Interfaces enthalten. Eine konsequente Namenskonvention hilft den Überblick zu behalten. Dabei werden die Interfaces grundlegend nach der Form benannt, also nach Parametern und Rückgabewerten. Diese grundlegenden Interfaces arbeiten mit Objekten. Für Interfaces, die dieselbe Operation für Primitive bereitstellen, wird der Name des primitiven Typs vorangestellt:</p>\n<ul>\n<li>Function&lt;T, R&gt; erwartet ein Objekt vom Typ T als Parameter und gibt ein Objekt vom Typ R zurück.</li>\n<li>ToIntFunction&lt;T&gt; erwartet ein Objekt vom Typ T als Parameter und gibt einen int-Wert zurück.</li>\n<li>DoubleToIntFunction erwartet einen double-Wert als Parameter und gibt einen int-Wert zurück.</li>\n</ul>\n<p>Nicht alle möglichen Kombinationen stehen zur Verfügung, aber die am häufigsten gebrauchten sind da. Nachfolgend schauen wir uns die grundlegenden Formen von funktionalen Interfaces an.</p>\n<h3>Function</h3>\n<p>Funktionsobjekte entsprechen in etwa der mathematischen Definition von einstelligen Funktionen: Sie bilden einen Wert auf einen anderen ab. Eine einfache Function ist eine Abbildung von einem Objekt auf ein anderes Objekt, eine ToIntFunction eine Abbildung von einem Objekt auf einen int-Wert usw.</p>\n<p>Im vorherigen Codebeispiel haben wir eine Anwendung für ToIntFuntion gesehen, dort werden Objekte auf einen Int-Wert abgebildet, der anschliessend zu einer laufenden Summe addiert wird. Auch die Methode Comparator.comparing erwartet ein Function-Objekt als Parameter:</p>\n<p><code>Comparator&lt;Song&gt; nachTitel = Comparator.comparing(s -&gt; s. getTitel());</code></p>\n<p>In diesem Beispiel werden Songs nach ihrem Titel sortiert, indem jeder Song als einen String, sein Titel abbildet und anschliessend nach der natürlichen Reihenfolge dieser Strings sortiert wird. Genau in diesem Fall können Sie auch eine Methodenreferenz verwenden: (da der Lambda-Ausdruck lediglich aus einem parameterlosen Methodenaufruf besteht):</p>\n<p><code>Comparator&lt;Song&gt; nachTitel = Comparator.comparing(Song::getTitel);</code></p>\n<p>Es gibt aber auch Funktionen deren Eingabe- und Ausgabetypen identisch sind, diese werden als Unary-Operator bezeichnet. So gibt es zum Beispiel den IntUnaryOperator, der einen int-Wert auf einen anderen int-Wert abbildet.</p>\n<h3>Predicate</h3>\n<p>Funktionen bei denen der Eingabewert immer auf eine boolean-Ausgabe abgebildet wird, werden Prädikate genannt. Predicate könnte also auch ToBooleanFunction heisst, hat aber wegen seiner besonderen Bedeutung einen eigenen Namen erhalten. Predicate sind besonders wichtig zum Filtern. Damit kann ein Stream mit einem Predicate-Objekt gefiltert werden, so dass nur noch die Elemente enthalten sind, die das Prädikat erfüllen, für die der Lambda-Ausdruck also true zurückgibt:</p>\n<p><code>List&lt;Song&gt; songs = …;</code><br><code>songs.stream().filter(s -&gt; s. getSterne() == 5).count();</code></p>\n<p>Doch damit nicht genug, es ist weiter möglich Predicate mit logischen Operatoren AND, OR und NOT anzuwenden und somit mehrere Predicate zu einem einzigen zu verknüpfen:</p>\n<p><code>private static Predicate&lt;Song&gt; baueSuchPredicate(String suchtitel,</code><br><code> String suchinterpret, int suchsterne) {</code><br><code>    Predicate&lt;Song&gt; filter = (s-&gt;true);</code><br><code>    if (suchtitel != null){</code><br><code>        filter = filter.and(s -&gt; </code><br><code>                s.getTitel().startsWith(suchtitel));</code><br><code>    }</code><br><code>    if (suchinterpret != null){</code><br><code>        filter = filter.and(s -&gt; </code><br><code>                s.getInterpret().startsWith(suchinterpret));</code><br><code>    }</code></p>\n<p><code></code><code> if (suchsterne &gt; 0){</code><br><code>        filter = filter.and(s -&gt; s. getSterne() &gt;= suchsterne);</code><br><code>    }</code><br><code>    return filter;</code><br><code>}</code></p>\n<p>Die Initialisierung mit Predicate&lt;Song&gt; filter = (s-&gt;true) wird deshalb so vorgenommen, damit es ein erstes Objekt gibt, an dem Sie überhaupt and rufen können. Anderenfalls müssten Sie bei jedem Suchattribut wieder prüfen, ob es schon einen Filter gibt, falls ja, and rufen, und falls nein, einen erzeugen.</p>\n<h3>Consumer</h3>\n<p>Dabei handelt es sich um Funktionen ohne Rückgabewert. Sie erwarten einen Parameter, den sie verarbeiten, liefern aber kein Ergebnis:</p>\n<p><code>public static void main(String[] args) throws IOException{</code><br><code>    liesStrings((s) -&gt; System.out.println(s));</code><br><code>}</code><br><code>    </code><br><code>public static void liesStrings(Consumer&lt;String&gt; sink) throws IOException{</code><br><code>    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));</code><br><code>    String line;</code><br><code>    while (!\"\".equals(line = in.readLine())){</code><br><code>        sink.accept(line);</code><br><code>    }</code><br><code>}</code></p>\n<p>Die Methode liesStrings liest so lange beliebig viele Strings von der Standardeingabe, bis eine leere Zeile gelesen wird und gibt jede gelesene teile an den übergebenen Consumer&lt;String&gt; weiter. Im Beispiel werden die gelesenen Strings einfach wieder ausgegeben, aber dieselbe Methode könnte eine Eingabe auch in einer Liste sammeln, oder jede Zeile als Kommando interpretieren:</p>\n<p><code>//Zeilen in eine Liste lesen</code><br><code>List&lt;String&gt; zeilen = new ArrayList&lt;&gt;();</code><br><code>liesStrings(zeilen::add);</code><br><code>//Zeilen als Kommandos ausführen</code><br><code>liesStrings(this::fuehreKommandoAus);</code></p>\n<h3>Supplier</h3>\n<p>Supplier ist das Gegenstück zum Consumer, sie haben keine Parameter, geben aber etwas zurück.</p>\n<p>Welchen Sinn kann ein solcher Aufruf</p>\n<p><code>zeigeNachricht(() -&gt; entschluessleNachricht(nachricht))</code><br><br>gegenüber dem folgenden, einfacheren haben?<br><br><code>zeigeNachricht(entschluessleNachricht(nachricht))</code><br><br>In diesem Beispiel können Sie unnötigen Rechenaufwand vermeiden. Die Methode zeigeNachricht stammt aus einem fiktiven E-Mail-Client, der Verschlüsselung beherrscht. Ihre Implementierung könnte so aussehen:<br><br><code>public zeigeNachricht(String nachricht){</code><br><code>    if (zeigeVorschau)</code><br><code>        System.out.println(nachricht);</code><br><code>}</code></p>\n<p>Im Beispiel wird die entschlüsselte Nachricht an die Methode übergeben, obwohl noch nicht klar ist, ob sie überhaupt benötigt wird. Wenn zeigeVorschau false ist, dann wird der Parameter ignoriert und die potenziell teure Entschlüsselung war umsonst.</p>\n<p><code>public zeigeNachricht(Supplier&lt;String&gt; nachricht){</code><br><code>    if (zeigeVorschau)</code><br><code>        System.out.println(nachricht.get());</code><br><code>}</code></p>\n<p>Nicht so in diesem Fall. Die Nachricht wird erst dann entschlüsselt, wenn am Supplier get gerufen wird, solange get nicht gerufen wird, wird die Nachricht nicht entschlüsselt.</p>\n<h3>BiFunction, BiPredicate, BiConsumer</h3>\n<p>Zu diesen Funktionen gibt es jeweils noch eine Variante mit einem vorangestellten Bi-. Diese unterscheiden sich von ihren einfachen Gegenstücken dadurch, dass sie zwei Parameter statt einem nehmen. Ein BiPredicate bildet also zum Beispiel zwei Objekte auf einen boolean-Wert ab. Funktionen die zwei gleichartige Wert auf einen dritten Wert desselben Typs abbilden heissen BinaryOperator.</p>",
            "author": {
                "name": "Finecloud"
            },
            "tags": [
                   "softwareentwicklung",
                   "lambda",
                   "java",
                   "interface",
                   "functional",
                   "dev"
            ],
            "date_published": "2022-05-30T14:21:40+02:00",
            "date_modified": "2022-05-30T16:46:59+02:00"
        },
        {
            "id": "https://www.finecloud.ch/lambda-ausdruecke-2.html",
            "url": "https://www.finecloud.ch/lambda-ausdruecke-2.html",
            "title": "Lambda-Ausdrücke Teil 2",
            "summary": "Im ersten Teil zum Thema Lambda-Ausdrücke haben wir gelernt was Lambda-Ausdrücke sind und wie man diese verwenden kann. Im zweiten Teil schauen wir nun hinter die Kulissen, wie Lambda-Ausdrücke funktionieren. Zentral zum Verständnis, wie Lambda-Ausdrücke in Java funktionieren, ist der Begriff des funktionalen Interface. Das&hellip;",
            "content_html": "<p>Im ersten Teil zum Thema Lambda-Ausdrücke haben wir gelernt was Lambda-Ausdrücke sind und wie man diese verwenden kann. Im zweiten Teil schauen wir nun hinter die Kulissen, wie Lambda-Ausdrücke funktionieren.</p>\n<p>Zentral zum Verständnis, wie Lambda-Ausdrücke in Java funktionieren, ist der Begriff des <em>funktionalen Interface</em>. Das ist ein Interface, das nur eine Methode definiert. Das war bereits vor der Lambda Einführung eine übliche Möglichkeit, in Java Funktionalität als Parameter zu übergeben.</p>\n<p><code>Arrays.sort(einArray, new Comparator(){</code><br><code>    public int compareTo(Object o1, Object o2){…}</code><br><code>});</code></p>\n<p>Comparator ist ein funktionales Interface, es deklariert nur die Methode compareTo. Aber ein Lambda-Ausdruck kann überall dort, wo ein funktionales Interface als Parametertyp angeben wird eingesetzt werden. Das heisst auch als Comparator:</p>\n<p><code>Arrays.sort(songs, (song1, song2) -&gt; </code><br><code> song1.getLaengeInSekunden() - song2.getLaengeInSekunden())</code></p>\n<p>Das funktioniert mit allen funktionalen Interfaces, auch eigene. Wenn Sie ein Interface deklarieren, das nur eine Methode enthält, dann können Sie, um dieses Interface zu implementieren, auch Lambda-Ausdrücke verwenden.</p>\n<h3>Closures</h3>\n<p>Oft wird für Lambda-Ausdrücke auch der Begriff Closure verwendet. Die beiden gehören untrennbar zusammen, sind aber nicht dasselbe.</p>\n<p>Ein Lambda-Ausdruck ist definiert als eine anonyme Funktion. Er erfüllt dieselbe Aufgabe wie eine Methode, hat aber keinen Namen.</p>\n<p>Ein Closure hingegen ist ein Bündel aus einer Funktion und der Umgebung, aus der heraus diese Funktion aufgerufen wurde. Mit Umgebung sind hier die lokalen Variablen gemeint welche zum Zeitpunkt des Aufrufs im Scope liegen. Das beim Erzeugen der anonymen Objektinstanz oder der Lambda-Instanz eine Closure gebildet wird, erlaubt es, auf die Werte der lokalen Variablen auch dann noch zuzugreifen, wenn sie schon nicht mehr im Scope liegen:</p>\n<p><code>public static void main(String[] args) throws Exception {</code><br><code>    IntSupplier test = erzeugeClosure();</code><br><code>    new Thread(() -&gt; System.out.println(test.getAsInt())).start();</code><br><code>}</code><br><code>public static IntSupplier erzeugeClosure() {</code><br><code>    int wert = 123;</code><br><code>    return (() -&gt; wert);</code><br><code>}</code></p>\n<p>Die Funktion <em>erzeugeClosure</em> gibt eine Instanz des funktionalen Interface <em>IntSupplier</em> zurück, die als Lambda angegeben ist. Die <em>main</em>-Methode führt diese zurückgegebene Instanz in einem neuen Thread aus, indem sie ihre <em>getAsInt</em>-Methode ruft. Obwohl der Wert dieser Variable zu diesem Zeitpunkt nicht mehr im Scope liegt, kommt es zur Ausgabe \"123\". Das ist möglich, weil die Variable in der Closure, die für den Lambda-Ausdruck erzeugt wird, noch vorhanden ist. <strong>Der Lambda-Ausdruck ist das, was Sie in Ihrem Code niederschreiben. Erst zur Laufzeit wird daraus und aus der Ausführungsumgebung eine Closure.</strong></p>\n<p> </p>",
            "author": {
                "name": "Finecloud"
            },
            "tags": [
                   "softwareentwicklung",
                   "lambda",
                   "java",
                   "dev"
            ],
            "date_published": "2022-05-29T15:35:47+02:00",
            "date_modified": "2022-05-29T15:35:47+02:00"
        },
        {
            "id": "https://www.finecloud.ch/lambda-ausdruecke.html",
            "url": "https://www.finecloud.ch/lambda-ausdruecke.html",
            "title": "Lambda-Ausdrücke Teil 1",
            "summary": "Seit Java 8 können mit Lambda Expressions Funktionen komfortabler, kürzer und lesbarer ausgedrückt werden. Nachfolgend ein Beispiel von Java Code. Dieses Stück Code sucht aus Ihrer Musiksammlung die 100 längsten Songs heraus, die Sie mit mehr als vier Sternen bewertet haben und deren Interpret Ihnen&hellip;",
            "content_html": "<p>Seit Java 8 können mit Lambda Expressions Funktionen komfortabler, kürzer und lesbarer ausgedrückt werden.</p>\n<p>Nachfolgend ein Beispiel von Java Code. Dieses Stück Code sucht aus Ihrer Musiksammlung die 100 längsten Songs heraus, die Sie mit mehr als vier Sternen bewertet haben und deren Interpret Ihnen nicht bekannt ist, und berechnet die Gesamtlänge dieser Songs:</p>\n<p><code>List&lt;Song&gt; songs = …;</code><br><code>int sekunden = 0;</code><br><code>Sekunden</code><br><code>Collections.sort(songs, new Comparator&lt;Song&gt;(){</code><br><code>    @Override</code><br><code>    public int compare(Song o1, Song o2) {</code><br><code>        return o1.getLaengeInSekunden() - o2. getLaengeInSekunden ();</code><br><code>    }</code><br><code>});</code><br><code>int zaehler = 0;</code><br><code>for (Song song : songs){</code><br><code>    if (song.getSterne() &gt; 4 </code><br><code>            &amp;&amp; (\"Unbekannter Künstler\".equals(song.getInterpret())){</code><br><code>        sekunden += song.getLaengeInSekunden();</code><code></code><br><code>        if (++zaehler &gt; 100) break;</code><br><code>    }</code><br><code>}</code></p>\n<p>Nachfolgend der Java Code der den gleichen Zweck erfüllt, aber Lambda Ausdrücke verwendet:</p>\n<p><code>int sekunden = songs.stream()</code><br><code>    .filter(song -&gt; \"Unbekannter Künstler\".equals(song.getInterpret()))</code><br><code>    .filter(song -&gt; song.getSterne() &gt; 4)</code><br><code>    .sorted(Comparator.comparing(Song::getLaengeInSekunden).reversed())</code><br><code>    .limit(100)</code><br><code>    .mapToInt(Song::getLaengeInSekunden)</code><br><code>    .sum();</code></p>\n<p>Die Vorteile liegen auf der Hand: Abgesehen von der Zeilen und Codelänge ist der Code auch viel einfach verständlich, schnell lässt sich erkennen, was der Code bewirkt. In den ersten beiden Zeilen wird die Liste gefiltert (filter), danach sortiert (sorted), auf die 100 ersten Ergebnisse beschränkt (limit), jeder Song auf sein int-Feld laengeInSekunden abgebildet (mapToInt) und von den Längen schliesslich die Summe (sum) berechnet</p>\n<h3>Was sind Lambda-Ausdrücke?</h3>\n<p>Es handelt sich dabei um Javas Sprachmittel, um Funktionen auszudrücken, im Gegensatz dazu stehen die prozedualen Konstrukte wie Verzweigungen und Schleifen, mit denen der Programmierablauf dargestellt wird. Lambda-Ausdrücke erlauben es zusammen mit entsprechenden APIs im Code nur das Wesentliche zu schreiben, ohne dabei jedes Mal das Übliche wiederholen zu müssen. Das Wesentliche ist eine Liste von Songs zu filtern. Das Übliche wäre in diesem Fall, über eine Liste zu iterieren und jedes Element zu prüfen.</p>\n<p>Ohne Lambda-Ausdrücke wird der Code länger, wenige gut lesbar und Fehleranfälliger, denn in Schleifen und Prüfungen schleichen sich gerne Fehler ein.</p>\n<h3>Die Lambda-Syntax</h3>\n<p>Lambda-Ausdrücke sind auf den ersten Blick als solche erkennbar durch den Pfeil -&gt;, der vorkommen muss und in Java keine andere Bedeutung hat.</p>\n<p><code>(Song song) -&gt; {</code><br><code>    return \"Unbekannter Künstler\".equals(song.getInterpret());</code><br><code>}</code></p>\n<p>Links vom Pfeil stehen die Parameter und rechts vom Pfeil steht, was mit diesen parametern geschehen soll. Mehrere Parameter werden, genau wie bei einer Methodendeklaration auch durch Kommas getrennt.</p>\n<p>Doch es geht noch kürzer. Es dürfen auch die Parametertypen wegfallen:</p>\n<p><code>(song) -&gt; {</code><br><code>    return \"Unbekannter Künstler\".equals(song.getInterpret());</code><br><code>}</code></p>\n<p>Der Java-Compiler ist inzwischen sehr gut darin, Typen aus dem Kontext zu erkennen. Da wir mit einer List&lt;Song&gt; arbeiten und daraus ein Stream&lt;Song&gt; wird, ist für den Compiler klar, dass der Typ des Rückgabewerts auch ein Song sein muss.</p>\n<p>Weiter darf, wenn der Lambda-Ausdruck nur ein Parameter benötigt die Klammer um den Parameter herum entfallen:</p>\n<p><code>song -&gt; {</code><br><code>    return \"Unbekannter Künstler\".equals(song.getInterpret());</code><br><code>}</code></p>\n<p>Wenn der Ausdruck allerdings keine Parameter hat, muss die Klammer wieder hin. Beispielsweise kann () -&gt; 3 ein gültiger Lambda-Ausdruck sein, der keine Parameter erwartet und die Zahl 3 zurückgibt.</p>\n<p>Als letzte Verkürzungsregel darf, wenn ein Rumpf eines Ausdrucks nur aus einem Ausdruck besteht, also einer einzigen Anweisung, die zu einem Wert ausgewertet wird (Vergleich, Berechnung oder Methodenaufruf) nur der Wert-Ausdruck selbst angegeben werden, ohne geschweifte Klammern, ohne Semikolon und ohne return:</p>\n<p><code>song -&gt; \"Unbekannter Künstler\".equals(song.getInterpret())</code></p>\n<p>Dabei gibt es aber keine Zwischenschritte, entweder man gibt den Ausdruck wie im letzten Beispiel an, oder man muss den Ausdruck mit geschweiften Klammern, Semikolon und return angeben. Natürlich ist die kürzeste Version anzustreben. Deshalb sollte immer auf die Blockschreibweise verzichtet werden, ausser man hat mehr als ein Wert-Ausdruck, beispielsweise bei einem if-Statement, hier müssen die äusseren Klammern und Returns geschrieben werden:</p>\n<p><code>(s1, s2) -&gt; {</code><br><code>    if (aufsteigend){</code><br><code>        return s1.getLaengeInSekunden() - s2.getLaengeInSekunden();</code><br><code>    } else {</code><br><code>        return s2.getLaengeInSekunden() - s1.getLaengeInSekunden();</code><br><code>    }</code><br><code>}</code></p>\n<p>Als letzte Spezialität in diesem Artikel gehe ich auf die Variable aufsteigend ein. Genau wie anonyme innere Klassen können Lambdas auf lokale Variabeln ihrer Umgebung zugreifen. Diese lokalen Variablen müssen nicht als final deklariert werden, müssen aber also solche behandelt werden. Das heisst, es reicht aus wenn ihnen im Lambda-Ausdruck oder danach kein neuer Wert mehr zugewiesen wird.</p>\n<h3>Methodenreferenz</h3>\n<p>Wenn ein Lambda-Ausdruck nur am einzigen übergebenen Parameter eine Methode aufruft und deren Rückgabewert weitergibt, dann kann statt des Lambda-Ausdrucks eine Methodenreferenz angeben werden. Die nachfolgenden Aufrufe haben die gleiche Wirkung:</p>\n<p><code>Comparator.comparing(song -&gt; song.getSterne());</code><br><code>Comparator.comparing(Song::getSterne);</code></p>\n<p>Methodenreferenzen erkennt man am doppelten Doppelpunkt. Davor steht die Klasse, dahinter die Methode. Wichtig ist, dass man bei der Methodenreferenz keine Klammern nach dem Methodenamen setzt. Das Beispiel von oben ist eine <em>ungebundene Referenz</em>: Sie bezeichnet nicht die getSterne-Methode eines bestimmten Objekts, sondern kann auf beliebige Objekte der Klasse Song angewendet werden. Ist vor dem doppelten Doppelpunkt keine Klasse, sondern eine Objektreferenz, dann ist die Methodenreferenz gebunden und meint immer die Methode dieses einen Objekts.</p>\n<p><code>Musicplayer player = new Musicplayer();</code><br><code>songs</code><br><code>        .filter(s -&gt; s. getSterne() == 5)</code><br><code>        .forEach(player::play);</code></p>\n<p>Die Referenz player::play meint immer die play-Methode des Musicplayer, den die Variable player referenziert. Mit Lambda-Ausdrücken, aber ohne Methodenreferenz, sähe das Beispiel dann so aus:</p>\n<p><code>Musicplayer player = new Musicplayer();</code><br><code>songs</code><br><code>        .filter(s -&gt; s. getSterne() == 5)</code><br><code>        .forEach(s -&gt; player.play(s));</code></p>",
            "author": {
                "name": "Finecloud"
            },
            "tags": [
                   "softwareentwicklung",
                   "lambda",
                   "java",
                   "dev"
            ],
            "date_published": "2022-05-29T09:56:24+02:00",
            "date_modified": "2022-05-29T15:04:11+02:00"
        },
        {
            "id": "https://www.finecloud.ch/java-die-pecs-regel.html",
            "url": "https://www.finecloud.ch/java-die-pecs-regel.html",
            "title": "Java Maps",
            "summary": "Maps werden auf Deutsch auch als assoziative Arrays bezeichnet. Ein Array ordnet ein Objekt einer Zahl zu, dem Index. Eine Map ordnet ein Objekt, den Wert, einem anderen Objekt zu, dem Schlüssel. Damit ist es möglich Zuordnungen von einem beliebigen Typ zu einem beliebigen anderen&hellip;",
            "content_html": "<p>Maps werden auf Deutsch auch als <em>assoziative Arrays</em> bezeichnet. Ein Array ordnet ein Objekt einer Zahl zu, dem Index. Eine Map ordnet ein Objekt, den Wert, einem anderen Objekt zu, dem Schlüssel. Damit ist es möglich Zuordnungen von einem beliebigen Typ zu einem beliebigen anderen Typ vorzunehmen. Häufig werden Strings als Schlüssel verwendet, es kann aber jeder Objekttyp als Schlüssel dienen.</p>\n<p>Eine Map besteht aus zwei Typparameter, den ersten für den Schlüssel und den zweiten für den Wert. Die Map wordCount ist eine Zuordnung von einem String-Schlüssel zu einem Integer-Wert, es ist die am häufigsten verwendete Implementierung von Map:</p>\n<p><code>private Map&lt;String, Integer&gt; wordCounts = new HashMap&lt;&gt;();</code><br><code>  private void count(InputStream source){</code><br><code>    try(Scanner scan = new Scanner(source)){</code><br><code>        scan.useDelimiter(\"[^\\\\p{IsAlphabetic}]+\");</code><br><code>        while (scan.hasNext()){</code><br><code>            String word = scan.next().toLowerCase();</code><br><code>            totalCount++;</code><br><code>            wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);</code><br><code>        }</code><br><code>    }    </code><br><code>}</code></p>\n<p>Die put-Methode fügt ein Element hinzu (falls bereits ein Element zugeordnet ist, wird es Überschrieben), die get-Methode gibt den einem Schlüssel zugeordneten Wert zurück. GetOrDefault hat dieselbe Funktion, nur das zusätzlich ein Default-Wert übergeben werden kann, der zurückgegeben wird, falls der angegebene Schlüssel nicht in der Map enthalten ist.</p>\n<p>Hier ein weiteres Beispiel einer Geburtstagsliste:</p>\n<p><code>public class Geburtstagsliste {</code><br><code>    private Map&lt;String, LocalDate&gt; geburtstage = new TreeMap&lt;&gt;();</code><br><code>    </code><br><code>    public void fuegeGeburtstagHinzu(String name, LocalDate geburtstag){</code><br><code>        geburtstage.put(name, geburtstag);</code><br><code>    }</code><br><code>    </code><br><code>    public LocalDate findeGeburtstag(String name){</code><br><code>        return geburtstage.get(name);</code><br><code>    }</code><br><code>    </code><br><code>    public void schreibeGeburtstage(){</code><br><code>        for(Map.Entry&lt;String, LocalDate&gt; entry : geburtstage.entrySet()){</code><br><code>            System.out.println(entry.getKey() + \": \" + entry.getValue());</code><br><code>        }</code><br><code>    }</code><br><code>}</code></p>\n<p>Ein weiteres Feature von Map ist, dass man über eine Map iterieren kann:</p>\n<table style=\"border-collapse: collapse; width: 100%;\" border=\"1\">\n<tbody>\n<tr>\n<td style=\"width: 49.9288%;\"><strong>Methode</strong></td>\n<td style=\"width: 49.9288%;\"><strong>Funktion</strong></td>\n</tr>\n<tr>\n<td style=\"width: 49.9288%;\">entrySet</td>\n<td style=\"width: 49.9288%;\">Liefert ein Set von Map.Entry-Objekten, die Key (Schlüssel) und Value (Wert) eines Eintrags enthalten</td>\n</tr>\n<tr>\n<td style=\"width: 49.9288%;\">keySet</td>\n<td style=\"width: 49.9288%;\">Liefert eine Collection aller Schlüssel</td>\n</tr>\n<tr>\n<td style=\"width: 49.9288%;\">values</td>\n<td style=\"width: 49.9288%;\">Liefert eine Collection aller Werte</td>\n</tr>\n</tbody>\n</table>\n<p> </p>",
            "author": {
                "name": "Finecloud"
            },
            "tags": [
                   "softwareentwicklung",
                   "maps",
                   "java",
                   "dev",
                   "collection"
            ],
            "date_published": "2022-05-28T14:53:33+02:00",
            "date_modified": "2022-05-28T20:17:04+02:00"
        },
        {
            "id": "https://www.finecloud.ch/java-genereische-methoden-und-beschraenkte-typen.html",
            "url": "https://www.finecloud.ch/java-genereische-methoden-und-beschraenkte-typen.html",
            "title": "Genereische Java Methoden und beschränkte Typen",
            "summary": "Eine Methode kann einen typisierten Parameter erzwingen und einen typisierten Wert zurückgeben: public List&lt;Integer&gt; parseAlleInts(List&lt;String&gt; strings){ List&lt;Integer&gt; ergebnis = new ArrayList&lt;&gt;(); for (String s : strings){ ergebnis.add(Integer.parseInt(s)); } return ergebnis; } So ist es möglich eine Liste von Strings als Paramter in eine Liste von&hellip;",
            "content_html": "<p>Eine Methode kann einen typisierten Parameter erzwingen und einen typisierten Wert zurückgeben:</p>\n<p><code>public List&lt;Integer&gt; parseAlleInts(List&lt;String&gt; strings){        </code><br><code>    List&lt;Integer&gt; ergebnis = new ArrayList&lt;&gt;();</code><br><code>    for (String s : strings){</code><br><code>        ergebnis.add(Integer.parseInt(s));</code><br><code>    }</code><br><code>    return ergebnis;</code><br><code>}</code></p>\n<p>So ist es möglich eine Liste von Strings als Paramter in eine Liste von Zahlen (Integern) umzuwandeln.</p>",
            "author": {
                "name": "Finecloud"
            },
            "tags": [
                   "softwareentwicklung",
                   "parameterlisten",
                   "java",
                   "dev",
                   "collectionlist",
                   "collection"
            ],
            "date_published": "2022-05-28T14:39:55+02:00",
            "date_modified": "2022-05-28T20:17:55+02:00"
        },
        {
            "id": "https://www.finecloud.ch/java-collection-iteratoren.html",
            "url": "https://www.finecloud.ch/java-collection-iteratoren.html",
            "title": "Java Collection Iteratoren",
            "summary": "Diese Collection Methode kann dazu verwendet werden, über alle Werte einer Collection zu iterieren: die Methode iterator, gibt ein Objekt vom Typ Iterator zurück. Mit der Methode hasNext wird geprüft, ob es noch ein weiteres Element in der Collection gibt, next gibt das nächste Element&hellip;",
            "content_html": "<p>Diese Collection Methode kann dazu verwendet werden, über alle Werte einer Collection zu iterieren: die Methode <em>iterator</em>, gibt ein Objekt vom Typ <em>Iterator</em> zurück.</p>\n<p>Mit der Methode <em>hasNext</em> wird geprüft, ob es noch ein weiteres Element in der Collection gibt, <em>next</em> gibt das nächste Element zurück:</p>\n<p><code>List&lt;Book&gt; books = …;</code><br><code>Iterator&lt;Book&gt; it = books.iterator();</code><br><code>while (it.hasNext){</code><br><code>    Book book = it.next();</code><br><code>    …</code><br><code>}</code></p>\n<p>Seit Java 5 und der Einführung der for-each-Schleife ist es nur noch selten nötig, selbst mit dem Interator zu arbeiten. Ein wesentlicher Vorteil ist, dass es keine Sprachkonstrukte, sondern Objekte sind und können als solche in Feldern gespeichert und als Parameter an Methoden übergeben und aus Methoden zurückgegeben werden. Beispielsweise kann damit ein einzelnen Element ausgelesen werden und zu einem späteren Zeitpunkt an derselben Stelle fortgesetzt werden:</p>\n<p><code>public boolean spieleHoerbuch(Iterator&lt;Book&gt; books, int zeit) {</code><br><code>    int gesamtzeit = 0;</code><br><code>    while (gesamtzeit &lt; zeit) {</code><br><code>        if (books.hasNext()) {</code><br><code>            Book book = books.next();</code><br><code>            gesamtzeit += book.getLaenge();</code><br><code>            spieleBook(book);</code><br><code>        } else {</code><br><code>            return false;</code><br><code>        }</code><br><code>    }</code><br><code>    return books.hasNext();</code><br><code>}</code></p>\n<p>In diesem Beispiel werden solange Hörbücher abgespielt, bis eine Gesamtzeit erreicht ist, dann wird das aktuelle Hörbuch zu ende gespielt. Wenn Sie die Methode das nächste Mal aktivieren, dann übergeben Sie denselben Iterator und es geht mit dem nächsten Hörbuch weiter.</p>",
            "author": {
                "name": "Finecloud"
            },
            "tags": [
                   "softwareentwicklung",
                   "java",
                   "dev",
                   "collectioniterator",
                   "collection",
                   "array"
            ],
            "date_published": "2022-05-26T14:07:33+02:00",
            "date_modified": "2022-05-26T14:18:44+02:00"
        },
        {
            "id": "https://www.finecloud.ch/java-collection-sets.html",
            "url": "https://www.finecloud.ch/java-collection-sets.html",
            "title": "Java Collection Sets",
            "summary": "Sets eignen sich für die Bearbeitung einer mathematischen Menge. Set kann somit keine identische Elemente enthalten und kann keine interneReihenfolge haben. Deshalb gibt es für Set auch keine Methoden die den direkten Zugriff auf ein Element ermöglichen. Um auf ein Element eines Set zuzugreifen muss&hellip;",
            "content_html": "<p>Sets eignen sich für die Bearbeitung einer mathematischen Menge. Set kann somit keine identische Elemente enthalten und kann keine interneReihenfolge haben. Deshalb gibt es für Set auch keine Methoden die den direkten Zugriff auf ein Element ermöglichen. Um auf ein Element eines Set zuzugreifen muss darüber iteriert werden:</p>\n<p><code>Set&lt;String&gt; besuchteOrte = new HashSet&lt;&gt;();</code><br><code>besuchteOrte.add(\"Bern\");</code><br><code>besuchteOrte.add(\"Basel\");</code><br><code>besuchteOrte.add(\"Bern\");</code><br><code>besuchteOrte.add(\"Bellinzona\");</code><br><code>for (String ort : besuchteOrte){</code><br><code>    System.out.println(ort);</code><br><code>}</code></p>\n<p>Im Beispiel wird Bern nur einmal ausgegeben, auch wenn Bern zweimal hinzugefügt wurde, zählt es nur einmal. Beim Hinzufügen ein neuen Elementen mit der add-Methode, gibt die Collection einen boolean-Wert zurück: Wenn das Element hinzugefügt wurde, ist der return true, wenn der Wert bereits vorhanden war, false. So kann festgestellt werden, ob ein neues Element hinzugefügt wurde, oder nicht. Wichtig zu beachten ist zudem, dass die Ausgabe eines Collection Sets nicht in einer festgelegen Reihenfolge erfolgt und es auch keine konstante Reihenfolge der Werte in einem Collection Set gibt.</p>\n<p>Die Hauptverwendung von Set, ist HashSet, das die Einmaligkeit der enthaltenen Elemente durch deren Hashcode sicherstellt. Wenn man also eine Set Collection verwenden, sollte man unbedingt in der Klasse die Methoden hashCode und equals überschreiben:</p>\n<p><code>Set&lt;Book&gt; meineBuecher = new HashSet&lt;&gt;();</code><br><code>meineBuecher.add(new Book(\"Bretonische Nächte\", \"Jean-Luc Bannalec\", 298));</code><br><code>meineBuecher.add(new Book(\"Bretonische Nächte\", \"Jean-Luc Bannalec\", 316));</code></p>\n<p>Wenn die Klasse Book die hashCode Methode nicht überschreibt, dann ist \"Bretonische Nächte\" zweimal im Set enthalten, denn die von Object geerbte bashCode-Implementierung gibt für verschiedene Objekte verschiedene Werte zurück, auch wenn die Objekte Inhaltsgleich sind. Deshalb muss eine eigene hashCode-Methode geschrieben werden, die den Code aus Titel, Autor und Seitenzahl berechnet, dann wird das zweite Buch nicht hinzugefügt, weil das Buch jetzt als identisch erkannt wird.</p>\n<p> </p>",
            "author": {
                "name": "Finecloud"
            },
            "tags": [
                   "softwareentwicklung",
                   "java",
                   "dev",
                   "collectionset",
                   "collection",
                   "array"
            ],
            "date_published": "2022-05-26T13:28:00+02:00",
            "date_modified": "2022-05-26T14:03:21+02:00"
        },
        {
            "id": "https://www.finecloud.ch/java-collection-listen.html",
            "url": "https://www.finecloud.ch/java-collection-listen.html",
            "title": "Java Collection Listen",
            "summary": "Listen sind Collections, die am ehesten einem Array entsprechen. Die Elemente bleiben in der Reihenfolge wie sie hinzugefügt werden und sie können auf einzelne Positionen im Index der Liste zugreifen: lesen mit get(index) und schreiben mit set(index, element). Damit ist mit Listen alles möglich, was&hellip;",
            "content_html": "<p>Listen sind Collections, die am ehesten einem Array entsprechen. Die Elemente bleiben in der Reihenfolge wie sie hinzugefügt werden und sie können auf einzelne Positionen im Index der Liste zugreifen: lesen mit <em>get(index) </em>und schreiben mit <em>set(index, element).</em></p>\n<p>Damit ist mit Listen alles möglich, was man mit Arrays auch kann, einfach mit mehr Komfort. Die Liste wächst bei neuen Elementen automatisch an und wenn ein Element mit remove entfernt wird, wird die Lücke geschlossen, indem alle nachfolgenden Elemente nachrutschen:</p>\n<p><code>List&lt;Book&gt; booklist = new ArrayList&lt;&gt;();</code><br><code>//Der Booklist zwei Books hinzufügen</code><br><code>booklist.add(new Book(…));</code><br><code>booklist.add(new Book(…));</code><br><code>//Das zweite Buch durch ein anderes ersetzen</code><br><code>booklist.set(1, new Book(…));</code><br><code>//Alle Buecher anzeigen</code><br><code>for (Book book : booklist){</code><br><code>    System.out.println(book.getTitel());</code><code></code><br><code>}</code></p>\n<p>Für die meisten Fälle ist die ArrayList die performanteste aller List-Implementierungen.</p>",
            "author": {
                "name": "Finecloud"
            },
            "tags": [
                   "softwareentwicklung",
                   "java",
                   "dev",
                   "collectionlist",
                   "collection",
                   "arraylist",
                   "array"
            ],
            "date_published": "2022-05-26T13:19:01+02:00",
            "date_modified": "2022-05-26T14:44:15+02:00"
        },
        {
            "id": "https://www.finecloud.ch/java-collections.html",
            "url": "https://www.finecloud.ch/java-collections.html",
            "title": "Java Collections",
            "summary": "Collections sind ganz alltägliche Java Objekte. Im Gegensatz zu Arrays sind Collections nicht durch native Methoden und einem zusammenhängenden Speicherbereich optimiert, sie haben auch keine eigene Syntax. Die Vorteile von Collections sind der Benutzerkomfort, da sie über eine umfangreichere und komfortablere API verfügen. Zudem können&hellip;",
            "content_html": "<p>Collections sind ganz alltägliche Java Objekte. Im Gegensatz zu Arrays sind Collections nicht durch native Methoden und einem zusammenhängenden Speicherbereich optimiert, sie haben auch keine eigene Syntax. </p>\n<p>Die <strong>Vorteile von Collections</strong> sind der <strong>Benutzerkomfort</strong>, da sie über eine <strong>umfangreichere und komfortablere API</strong> verfügen. Zudem können verschiedene Implementierungen des Interface Collection, je nach Anwendungsfall verwendet werden. Der wohl grösste Vorteil, ist das Collections <strong>keine Grösse Vorgeben, Collections wachsen bei Bedarf.</strong></p>\n<blockquote>\n<p>Arrays eignen sich deshalb besondern für Performance getrimmte und Systemnahe Applikationen, während Collections eher für Anwendungen geeignet sind, bei denen es nicht auf jede Nanosekunde ankommt und der Vorteil des Komforts überwiegt.</p>\n</blockquote>\n<p>Standardmässig arbeiten Collections einfach mit dem Typ Object. Wenn man will, kann man einer Collection einen bestimmten Typ mitgeben:</p>\n<p><code> Collection&lt;Buch&gt; playlist = new ArrayList&lt;&gt;();</code></p>\n<p>Es gibt bei Collections keine Methoden für den Zugriff auf ein bestimmtes Element. Der allgemeine Ansatz, an den Inhalt einer Collection heranzukommen, ist der, sie in einer for-each-Schleife zu durchlaufen oder mit der Methode iterator ein Iterator-Objekt zu erzeugen. Nachfolgend sind die wichtigsten Methoden aufgelistet:</p>\n<table style=\"border-collapse: collapse; width: 100%; height: 287.828px;\" border=\"1\">\n<tbody>\n<tr style=\"height: 50.3594px;\">\n<td style=\"width: 30.5463%; height: 50.3594px;\"><strong>Methoden von <em>java.util.Collection</em></strong></td>\n<td style=\"width: 69.4537%; height: 50.3594px;\"><strong>Beschreibung</strong></td>\n</tr>\n<tr style=\"height: 107.953px;\">\n<td style=\"width: 30.5463%; height: 107.953px;\">add / addAll</td>\n<td style=\"width: 69.4537%; height: 107.953px;\">Fügen einer Collection ein Objekt, bzw. alle Objekte einer anderen Collection hinzu.</td>\n</tr>\n<tr style=\"height: 79.1562px;\">\n<td style=\"width: 30.5463%; height: 79.1562px;\">contains / containsAll</td>\n<td style=\"width: 69.4537%; height: 79.1562px;\">Prüfen, ob ein oder mehrere Objekte in der Collection enthalten sind.</td>\n</tr>\n<tr style=\"height: 50.3594px;\">\n<td style=\"width: 30.5463%; height: 50.3594px;\">remove / removeAll</td>\n<td style=\"width: 69.4537%; height: 50.3594px;\">Entfernt Objekte aus der Collection</td>\n</tr>\n</tbody>\n</table>\n<p>Was wenn ich nun aber doch ein Array will? Dann kann ich mit der toArray-Methode jede Collection in ein Array umwandeln. Die parameterlose toArray-Methode liefert aber immer ein Object[], auch wenn ein Typ für die Collection angeben wurde. Es ist nicht möglich ein solches Object[] Array einfach in den gewünschten Typ zu casten. Wenn ich aber aus einer Collection von Buecher ein Buch[] machen will, dann muss ich die toArray-Methode mit Parameter übergeben:</p>\n<p><code>Collection&lt;Double&gt; liste = new ArrayList&lt;&gt;();</code><br><code>Double[] alsDoubles = liste.toArray(new Double[liste.size()]);</code><br><code>Number[] alsNumber = liste.toArray(new Number[liste.size()]);</code><br><code>Object[] alsObject = liste.toArray(new Object[liste.size()]);</code><br><code>Object[] auchAlsObject = liste.toArray();</code></p>\n<p>Wichtig ist, dass die Grösse des Arrays passt. Wenn das Array zu klein ist, dann ist der Rückgabewert ein neues Array des gleichen Typs mit der Grösse der Collection.</p>",
            "author": {
                "name": "Finecloud"
            },
            "tags": [
                   "softwareentwicklung",
                   "java",
                   "dev",
                   "collection",
                   "array"
            ],
            "date_published": "2022-05-26T12:49:28+02:00",
            "date_modified": "2022-05-26T13:27:11+02:00"
        },
        {
            "id": "https://www.finecloud.ch/java-varargs.html",
            "url": "https://www.finecloud.ch/java-varargs.html",
            "title": "Java Varargs",
            "summary": "Varargs, auch Parameter-Listen genannt können in Java Arrays verwendet werden, um eine dynamische Anzahl von Parametern entgegenzunehmen. public static int max(int… numbers){ int result = Integer.MIN_VALUE; for (int number : numbers){ if (number &gt; result){ result = number; } } return result; } Diese Methode&hellip;",
            "content_html": "<p>Varargs, auch Parameter-Listen genannt können in Java Arrays verwendet werden, um eine dynamische Anzahl von Parametern entgegenzunehmen.</p>\n<p><code>public static int max(int… numbers){</code><br><code>    int result = Integer.MIN_VALUE;</code><br><code>    for (int number : numbers){</code><br><code>        if (number &gt; result){</code><br><code>            result = number;</code><br><code>        }</code><br><code>    }</code><br><code>    return result;</code><br><code>}</code></p>\n<p>Diese Methode kann verwendet werden, um mit einer beliebigen Anzahl von int-Zahlen aufgerufen zu werden, um dir grösste aller Zahlen unter den Parametern zu finden. Innerhalb der Methode sind alle Parameter aus der Vararg-Liste als Array zu sehen.</p>\n<p>Die Methode kann wie folgt aufgerufen werden:</p>\n<p><code>public static void main(String[] args) {</code><br><code>    System.out.println(max(5, 10, 0));</code><br><code>}</code></p>\n<p>Entsprechend wird die grösste Zahl ausgegeben: 10</p>",
            "author": {
                "name": "Finecloud"
            },
            "tags": [
                   "varargs",
                   "softwareentwicklung",
                   "parameterlisten",
                   "java",
                   "dev",
                   "array"
            ],
            "date_published": "2022-05-25T20:17:32+02:00",
            "date_modified": "2022-05-25T20:38:17+02:00"
        }
    ]
}
