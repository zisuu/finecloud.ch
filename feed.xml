<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Finecloud</title>
    <link href="https://www.finecloud.ch/feed.xml" rel="self" />
    <link href="https://www.finecloud.ch" />
    <updated>2022-06-04T18:36:49+02:00</updated>
    <author>
        <name>Finecloud</name>
    </author>
    <id>https://www.finecloud.ch</id>

    <entry>
        <title>Dateien und Verzeichnisse unter Java</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/dateien-und-verzeichnisse-unter-java.html"/>
        <id>https://www.finecloud.ch/dateien-und-verzeichnisse-unter-java.html</id>
            <category term="verzeichnisse"/>
            <category term="softwareentwicklung"/>
            <category term="java.nio.files"/>
            <category term="java.io.file"/>
            <category term="java.io"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="dateien"/>

        <updated>2022-06-04T18:36:49+02:00</updated>
            <summary>
                <![CDATA[
                    Dateioperationen mit java.io werden in Java immer, direkt oder indirekt, durch ein Objekt des Typs java.io.File abgebildet. Dabei kann File aber nicht selbst aus Dateien lesen, oder in sie schreiben, dazu benötigt man einen Reader oder Writer (für Textdateien) resp. einen InputStream oder OutputStream (für&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Dateioperationen mit java.io werden in Java immer, direkt oder indirekt, durch ein Objekt des Typs java.io.File abgebildet. Dabei kann File aber nicht selbst aus Dateien lesen, oder in sie schreiben, dazu benötigt man einen Reader oder Writer (für Textdateien) resp. einen InputStream oder OutputStream (für Binärdateien).</p>
<h3>Dateien und Pfade</h3>
<p>Ein File wird immer aus einer Pfadangabe, entweder <em>absolut</em> oder <em>relativ</em> erzeugt. Absolut geht von einem Wurzelverzeichnis aus, zum Beispiel C:\ unter Windows, oder / unter Linux. Ein relativer Pfad bezieht sich dagegen auf das aktuelle Verzeichnis des Benutzers, normalerweise von dort aus woher das Programm aufgerufen wurde. Wenn die Datei unter dem angegebenen Pfad nicht existiert, wird auch keine entsprechende Datei unter dem definierten Pfad angelegt:</p>
<p><code>File windowsDatei = new File("C:\\home\\user\\text.txt");</code><br><code>File linuxDatei = new File("/home/user/text.txt");</code></p>
<p>Pfade werden also je nach OS unterschiedlich angegeben. Für Windows Pfade als Konstante sind effektiv zwei Doppel Backslashes zu verwenden! Solange die Pfadeingabe vom Benutzer selbst kommt, macht das keine Probleme. Wenn aber aus dem Programm heraus Dateipfade erzeugt werden müssen, dann müssen Sie auf diese Details acht geben. Das richtige Zeichen zum trennen von Verzeichnissen in einer Pfadangabe findet sich in der Konstanten File.separator. Damit lässt sich einen Pfad OS unabhängig erstellen: </p>
<p><code>File datei = new File(File.separator + "home" </code><br><code>    + File.separator + "user"</code><br><code>    + File.separator + "text.txt");</code></p>
<p>Unter Unix-basierten Systemen funktioniert dieser Code. Unter Windows bleibt das Problem mit dem Laufwerksbuchstaben. Dazu kann unabhängig vom OS, alle Wurzelverzeichnisse aufgelistet werden. Dazu kennt File die statische Methode listRoots. So lässt sich ein OS unabhängiger Code schreiben:</p>
<p><code>public File waehleWurzel(){</code><br><code>    File[] wurzeln = File.listRoots();</code><br><code>    if (wurzeln.length == 1){</code><br><code>        return wurzeln[0];</code><br><code>    } else {</code><br><code>        System. out.println("Bitte wählen Sie eine Wurzel");</code><br><code>        for (int i = 0; i &lt; wurzeln.length; i++){</code><br><code>            System.out.println(i + ": " + wurzeln[i]);</code><br><code>        }</code><br><code>        int index = liesZahl();</code><br><code>        return wurzeln[index];</code><br><code>    }</code><br><code>}</code></p>
<p>Doch das reicht immer noch nicht ganz, denn unter Windows kann es hier mehrere Einträge geben, je nachdem wieviele Laufwerke vorhanden sind (C:\, D:\ ...). In diesem Fall wird der Benutzer geben, ein Laufwerk auszuwählen. Anschliessend kann ein neues File-Objekt relativ zur ausgewählten Wurzel erzeugt werden, indem dies dem Konstruktor angegeben wird:</p>
<p><code>File wurzel = waehleWurzel();</code><br><code>File datei = new File(wurzel, "home"</code><br><code> + File.separator + "user"</code><br><code> + File.separator + "text.txt");</code></p>
<p>Ob eine Datei überhaupt existiert kann mit der Methode exists überprüft werden. Da ein File lediglich die objektorientierte Repräsentation eines Pfades ist, kann man Files erzeugen, ohne das diese Dateien bereits existieren. Falls keine Datei existiert kann eine neue Datei mit createNewFile oder mit mkdir ein Verzeichnis an der vom Pfad angegebenen Stelle angelegt werden. File liefert weitere Informationen über Dateien:</p>
<table style="border-collapse: collapse; width: 100%; height: 525.297px;" border="1">
<tbody>
<tr style="height: 50.3594px;">
<td style="width: 49.9288%; height: 50.3594px;"><strong>Methode</strong></td>
<td style="width: 49.9288%; height: 50.3594px;"><strong>Funktion</strong></td>
</tr>
<tr style="height: 107.953px;">
<td style="width: 49.9288%; height: 107.953px;">isFile()</td>
<td style="width: 49.9288%; height: 107.953px;">Prüft, ob es sich bei der angegebenen File-Objekt um eine Datei handelt, (oder einen Ordner)</td>
</tr>
<tr style="height: 107.953px;">
<td style="width: 49.9288%; height: 107.953px;">isDirectory()</td>
<td style="width: 49.9288%; height: 107.953px;">Prüft, ob es sich bei der angegebenen File-Objekt um einen Ordner handelt, (oder eine Datei)</td>
</tr>
<tr style="height: 50.3594px;">
<td style="width: 49.9288%; height: 50.3594px;">canRead()</td>
<td style="width: 49.9288%; height: 50.3594px;">Prüft, ob der Benutzer Leserechte hat</td>
</tr>
<tr style="height: 79.1562px;">
<td style="width: 49.9288%; height: 79.1562px;">canWrite()</td>
<td style="width: 49.9288%; height: 79.1562px;">Prüft, ob der Benutzer Schreibrechte hat</td>
</tr>
<tr>
<td style="width: 49.9288%;">canExectue()</td>
<td style="width: 49.9288%;">Prüft, ob der Benutzer Ausführungsrechte hat</td>
</tr>
<tr style="height: 79.1562px;">
<td style="width: 49.9288%; height: 79.1562px;">getName()</td>
<td style="width: 49.9288%; height: 79.1562px;">Liefert den Namen der Datei, ohne vorangehende Pfadangabe</td>
</tr>
<tr style="height: 50.3594px;">
<td style="width: 49.9288%; height: 50.3594px;">getParent()<br>getParentFile()</td>
<td style="width: 49.9288%; height: 50.3594px;">Liefert das übergeordnete Verzeichnis, entweder als String mit getParent oder als Objekt mit getParentFile</td>
</tr>
<tr>
<td style="width: 49.9288%;">lastModified()</td>
<td style="width: 49.9288%;">Liefert das letzte Änderungsdatum der Datei als long</td>
</tr>
<tr>
<td style="width: 49.9288%;">length()</td>
<td style="width: 49.9288%;">Liefert die Grösse der Datei in Byte als long</td>
</tr>
<tr>
<td style="width: 49.9288%;">delete</td>
<td style="width: 49.9288%;">eine Datei löschen</td>
</tr>
<tr>
<td style="width: 49.9288%;">renameTo</td>
<td style="width: 49.9288%;">eine Datei umbenennen</td>
</tr>
</tbody>
</table>
<p>java.io.File stellt jedoch keine Methoden zur Verfügung für das Kopieren oder verschieben von Dateien. Dazu gibt es aber seit Java 7 eine Hilfsklasse aus Files.</p>
<h3>Dateioperationen aus "Files"</h3>
<p>Die Klasse Files ist eine Sammlung von Hilfsmethoden für alles, was mit Dateien zu tun hat. Diese Klasse ist aber nicht im java.io-Package enthalten, sondern nur im java.nio.files. Damit ist es die einzige Klasse aus der Non-Blocking-I/O-API, die man auch beim alltäglichen Umgang mit Dateien regelmässig benutzt.</p>
<p>Da die Hilfsklasse zu der API java.nio.file.Path gehört und nicht zur java.io.File müssen bei jeder Operation die Parameter von File nach Path und die Rückgabewerte, falls Dateien zurückgegeben werden, wieder von Path nach File konvertiert werden. Dabei lassen sich nicht alle Path-Objekte nach File konvertieren, nur solche welche aus einer Operation auf einem File resultieren. Damit sind auch Kopier- und Verschiebeoperationen möglich. Die Verwendung dieser Methode macht mehr Sinn, als eine Eigenentwicklung in Java, da dies nicht nur praktischer ist, sondern auch effizienter die JDL Systemaufrufe verwenden kann.</p>
<p><code>//File nach Path konvertieren</code><br><code>Path quellPath = quelle.toPath();</code><br><code>Path zielPath = ziel.toPath();</code><br><code>//ENTWEDER Datei kopieren</code><br><code>Path ergebnisPath = Files.copy(quellPath, zielPath);</code><br><code>//ODER Datei verschieben</code><br><code>Path ergebnisPath = Files.move(quellPath, zielPath);</code><br><code>//Ergebnis - eigentlich wieder das Ziel - nach File konvertieren</code><br><code>File ergebnis = ergebnisPath.toFile();</code></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Stream.collect - Daten aus einem Stream sammeln</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/streamcollect-daten-aus-einem-stream-sammeln.html"/>
        <id>https://www.finecloud.ch/streamcollect-daten-aus-einem-stream-sammeln.html</id>
            <category term="stream-api"/>
            <category term="softwareentwicklung"/>
            <category term="lambda"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="collector"/>
            <category term="collect"/>

        <updated>2022-06-04T12:14:10+02:00</updated>
            <summary>
                <![CDATA[
                    Die mächtige collect-Methode ist mit zwei Signaturen überladen, collect(Supplier, BiConsumer, BiConsumer) und collect(Collector). Beide sind aber prinzipiell identisch; ein Collection ist lediglich ein Objekt, das die drei Funktionen zusammenfasst und wiederverwendbar macht. collect sieht etwas bedrohlich aus, weil man gleich drei Funktionen übergeben muss, die&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Die mächtige collect-Methode ist mit zwei Signaturen überladen, collect(Supplier, BiConsumer, BiConsumer) und collect(Collector). Beide sind aber prinzipiell identisch; ein Collection ist lediglich ein Objekt, das die drei Funktionen zusammenfasst und wiederverwendbar macht.</p>
<p>collect sieht etwas bedrohlich aus, weil man gleich drei Funktionen übergeben muss, die zusammen irgendwie Ihre Ausgabe erzeugen sollen. Jede Funktion hat eine klar definierte Aufgabe:</p>
<ul>
<li>Der <strong>Supplier</strong> erzeugt ein Objekt, in dem gesammelt werden soll. Wenn man mittels collection eine Liste aus einem Stream erzeugen will, dann muss der Supplier diese Liste erzeugen. Warum übergibt man dann nicht gleich das Objekt, in dem gesammelt werden soll? Weil der Supplier in einem parallelen Stream mehrmals gerufen wird: Es werden mehrere Listen erzeugt, die später zusammengefasst werden.</li>
<li>Die <strong>erste BiConsumer</strong>, genannt der <em>Akkumulator</em>, kombiniert ein Element des Streams mit einem der vom Supplier erzeugten Sammelobjekte. Um beim Beispiel der Liste zu bleiben, fügt diese Funktion der Liste ein Element hinzu.</li>
<li>Der <strong>zweite BiConsumer</strong>, der <em>Kombinator</em>, fügt zwei Sammelobjekte zu einem zusammen. Diese Funktion sorgt also dafür, dass am Ende nur eine Liste zurückgegeben wird, auch wenn mehrere vom Supplier erzeugt wurden. Damit das funktioniert, muss das Sammelobjekt eine Funktion haben, dir diesem Objekt den Inhalt eines anderen Objekts hinzufügt, wie zum Beispiel die Methode addAll an einer Liste.</li>
</ul>
<p>Das Beispiel zeigt, wie alle Stream-Elemente in einer Liste gesammelt werden können:</p>
<p><code>List&lt;Person&gt; personen = personenStream.collect(</code><br><code>        ArrayList::new, </code><br><code>        ArrayList::add, </code><br><code>        ArrayList::addAll);</code></p>
<p>collect funktioniert nicht nur mit Listen, auch wenn der Methodenname nach Collections klingt. Jedes Objekt, das geeignete Methoden bereitstellt, kann zum Sammeln verwendet werden. So sammeln Sie alle Titel aus Ihrer Musiksammlung in einem String:</p>
<p><code>String songliste = songs.collect(StringBuilder::new, </code><br><code> (acc, el) -&gt; acc.append(el.getTitel()).append("\n"), </code><br><code> StringBuilder::append).toString();</code></p>
<p>Die drei richtigen Funktionen für einen Collector anzugeben, kann schwierig sein. Als Hilfe können die statische Methoden der Companion-Klasse verwendet werden, die nützliche Kollektoren bereitstellt. Zum Beispiel die, welche aus einem Stream wieder eine Collection machen:</p>
<p><code>List&lt;Song&gt; songList = songs.collect(Collectors.toList());</code><br><code>Set&lt;Song&gt; songSet = songs.collect(Collectors.toSet());</code></p>
<p>Kollektoren können mehr als das, die nachfolgenden Möglichkeiten aus Collectors machen deutlich, wie mächtig die collect-Methode ist:</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td style="width: 49.9288%;"><strong>collectors-Methode</strong></td>
<td style="width: 49.9288%;"><strong>Funktion</strong></td>
</tr>
<tr>
<td style="width: 49.9288%;">mapToDouble().average()</td>
<td style="width: 49.9288%;">Durchschnitt berechnen</td>
</tr>
<tr>
<td style="width: 49.9288%;">.count()</td>
<td style="width: 49.9288%;">Elemente zählen</td>
</tr>
<tr>
<td style="width: 49.9288%;">.summarizingDouble</td>
<td style="width: 49.9288%;">Statistische Daten, Summe (Double)</td>
</tr>
<tr>
<td style="width: 49.9288%;">.summarizingInt</td>
<td style="width: 49.9288%;">Statistische Daten, Summe (Int)</td>
</tr>
<tr>
<td style="width: 49.9288%;">.summarizingLong</td>
<td style="width: 49.9288%;">Statistische Daten, Summe (Long)</td>
</tr>
</tbody>
</table>
<p><code>DoubleSummaryStatistics statistik = zeilen</code><br><code>    .flatMap(line -&gt; Arrays.stream(line.split("\\s+"))</code><br><code>        .skip(1))</code><br><code>    .collect(Collectors.summarizingDouble(Double::parseDouble));</code><br><code>    System.out.println("Kältester Monat: " + statistik.getMin() + " Grad.");</code><br><code>    System.out.println("Wärmster Monat: " + statistik.getMax() + " Grad.");</code><br><code>    System.out.println("Durchschnitt: " + statistik.getAverage() + " Grad.");</code></p>
<p>Für fortgeschrittene statistische Auswertungen reicht das zwar noch nicht, es fehlt zum Beispiel eine Varianz, aber wenn Sie diese Funktionalität benötigen, können Sie nach demselben Muster einen eigenen Kollektor schreiben.</p>
<p>Die wohl vielseitigsten collect-Operationen, die Collectors anbietet, sind Partitionierung und Gruppierung. Beide trennen die Elemente im Stream nach einem festgelegten Kriterium in mehrere Gruppen. Der Unterschied zwischen den beiden besteht nur darin, dass <em>partitioningBy</em> Elemente nach einem Prädikat in zwei Gruppen zerlegt, die true-Gruppe und die false-Gruppe, während <em>groupingBy</em> anhand einer Funktion beliebig viele Gruppen erzeugen kann, eine für jeden Wert, den die Funktion zurückgegeben hat. Beide geben eine Map zurück, in der die Schlüssel TRUE/FALSE oder die Rückgabewerte der Funktion enthalten sind, mit den Werten dazu als jeweils eine Liste aller Objekte, die in diese Gruppe sortiert wurden. Mit diesem Beispiel können Songs nach Interpret sortiert werden:</p>
<p><code>songs.collect(Collectors.groupingBy(Song::getInterpret));</code></p>
<p>Dieses Beispiel gibt eine Map zurück, deren Schlüssel die Namen der Interpreten sind, die dazugehörigen Werte sind Listen aller Songs dieses Interpreten. Wenn Sie noch einen Schritt weiter gehen wollen, können Sie <em>groupingBy</em> und <em>partitioningBy</em> einen weiteren Collector übergeben, der auf die Werte jeder Gruppe angewendet wird:</p>
<p><code>songs.collect(Collectors.groupingBy(</code><br><code> Song::getInterpret,</code><br><code> Collectors.maxBy(Comparator.comparing(Song::getSterne))));</code></p>
<p>So einfach bekommen Sie den besten Song jedes Interpreten. Erst werden Songs nach Interpret gruppiert, in jeder Gruppe wird anschliessend der Song mit der maximalen Anzahl Sterne gefunden.</p>
<p>Fast immer ist es egal, welche Art von Map Sie beim Gruppieren oder Partitionieren zurückbekommen, aber in seltenen Fällen möchten Sie eine bestimmte Art von Map nutzen, zum Beispiel eine SortedMap. Für diesen Fall können Sie auch noch einen Supplier übergeben, der die richtige Map-Implementierung erzeugt.</p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Endlose Streams</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/endlose-streams.html"/>
        <id>https://www.finecloud.ch/endlose-streams.html</id>
            <category term="threads"/>
            <category term="stream-api"/>
            <category term="softwareentwicklung"/>
            <category term="lambda"/>
            <category term="java"/>
            <category term="dev"/>

        <updated>2022-06-02T11:03:18+02:00</updated>
            <summary>
                <![CDATA[
                    Nicht jeder Stream ist endlich. Manche Streams erzeugen immer weiter Daten. Solche Streams nennt man auch Generatoren, weil sie ihre Daten selbst herstellen. Dazu gibt es in Stream und den primitiven Streams jeweils zwei statische Methoden, die einen solchen Stream erzeugen. Die generate-Methode arbeiten mit&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Nicht jeder Stream ist endlich. Manche Streams erzeugen immer weiter Daten. Solche Streams nennt man auch Generatoren, weil sie ihre Daten selbst herstellen. Dazu gibt es in Stream und den primitiven Streams jeweils zwei statische Methoden, die einen solchen Stream erzeugen.</p>
<p>Die <em>generate</em>-Methode arbeiten mit einem <em>Supplier</em>. Der so erzeugte Stream enthält nach und nach alle Werte, die dieser Supplier liefert. Ein solcher Stream ist sehr monoton, wenn der übergebene Supplier () -&gt; 1 lautet, aber er ist trotzdem endlos, denn der Supplier wird immer wieder aufgerufen. Zum Glück existieren auch interessantere Supplier.</p>
<p>Die zweite Möglichkeit, einen endlosen Stream zu erzeugen, heisst <em>iterate</em>. Diese Methode erzeugt einen Stream, indem sie eine übergebene Funktion immer wieder auf einen Standwert anwendet. Für einen Startwert n und eine Funktion f heisst das, der erzeugt Stream enthält die Werte [n, f(n), f(f(n)), f(f(f(n))), …]</p>
<p><code>Stream.iterate(BigInteger.ONE, i -&gt; i.multiply(two))</code><br><code>        .limit(1000)</code><br><code>        .forEach(System.out::println);</code></p>
<p>Das Beispiel erzeugt einen Stream alle Zweierpotenzen und gibt die ersten 1000 davon aus. Es versteht sich von selbst, dass manche Operationen auf einem endlosen Stream keine gute Idee sind. Ihn zu sortieren, führt eher zu Problemen, und auch bei einer forEach ohne limit sollte man sicher sein, was man tut. Für den zweiten Fall gibt es aber durchaus Anwendungen. So könnte man in einem Thread einen endlosen Stream von Ergebnissen erzeugen und jedes gefundene Ergebnis in einem anderen Thread verarbeiten.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Parallele Streams</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/parallele-streams.html"/>
        <id>https://www.finecloud.ch/parallele-streams.html</id>
            <category term="threads"/>
            <category term="stream-api"/>
            <category term="softwareentwicklung"/>
            <category term="parallel"/>
            <category term="lambda"/>
            <category term="java"/>
            <category term="dev"/>

        <updated>2022-05-31T12:06:01+02:00</updated>
            <summary>
                <![CDATA[
                    Streams können die Arbeit an Listen von Daten erheblich vereinfachen. Sie haben die Fähigkeit, die vor allem bei grossen Datenmengen extrem nützlich sein kann: Sie können in mehren Threads arbeiten. Das kann die Datenverarbeitung erheblich beschleunigen. Sie müssen dazu nicht selbst neue Threads starten, Streams&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Streams können die Arbeit an Listen von Daten erheblich vereinfachen. Sie haben die Fähigkeit, die vor allem bei grossen Datenmengen extrem nützlich sein kann: Sie können in mehren Threads arbeiten. Das kann die Datenverarbeitung erheblich beschleunigen.</p>
<p>Sie müssen dazu nicht selbst neue Threads starten, Streams erledigen das für Sie. Manchmal können Sie einen Stream gleich als einen parallelen Stream erzeugen, zum Beispiel, indem Sie an einer Collection parallelStream anstelle von stream aufrufen. Es ist aber auch möglich einen Stream nachträglich in einen parallelen Stream umzuwandeln, indem die Methode parallel gerufen wird, oder wieder in einen sequenziellen Stream, also einen Stream, der in nur einem Thread verarbeitet wird, mit der Methode sequential. Beide Methoden sind intermediär, dadurch können Sie sogar in einer Pipeline einige Schritte parallel und andere sequenziell ausführen:</p>
<p><code>studentenDatei</code><br><code>        .lines()</code><br><code>        .parallel()</code><br><code>        .map(line -&gt; parseStudent(line))</code><br><code>        .filter(student -&gt; student.getNotendurchschnitt() &gt;= 5.0)</code><br><code>        .sequential()</code><br><code>        .forEach(student -&gt; schreibeInDatei(student)); </code></p>
<p>Im Beispiel wird eine Datei mit Studentendaten eingelesen, darin werden alle Studenten mit einem Notendurchschnitt von 5.0 oder höher in eine neue Datei geschrieben. Dazu werden zunächst die aus der Datei gelesenen Strings in Student-Objekte gemappt und nach Notendurchschnitt gefiltert. Diese Operationen können parallel ausgeführt werden, ohne dass es zu Fehlern kommt. In die Ausgabedatei muss aber ein Datensatz nach dem anderen geschrieben werden, es können nicht mehrere Threads gleichzeitig in dieselbe Datei schreiben. Dazu wird von dem terminalen <em>forEach</em> der Stream wieder sequenziell gemacht. So sind die Aufgaben, die in mehreren Threads verarbeitet werden können, parallel, aber die, bei denen es nicht geht, sequenziell.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Die Stream-API</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/die-stream-api.html"/>
        <id>https://www.finecloud.ch/die-stream-api.html</id>
            <category term="stream-api"/>
            <category term="softwareentwicklung"/>
            <category term="lambda"/>
            <category term="java"/>
            <category term="dev"/>

        <updated>2022-06-01T14:35:56+02:00</updated>
            <summary>
                <![CDATA[
                    Das konsequente Fluent Interface der Stream-API macht es möglich, mit einem Blick zu erkennen was durch einen Lambda-Ausdruck in jeder einzelnen Zeile geschieht. Mit diesem Beispiel werden alle Vielfachen von 3 zwischen 0 und 100 ausgegeben: IntStream.range(0, 100) .filter(i -&gt; i % 3 == 0)&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Das konsequente Fluent Interface der Stream-API macht es möglich, mit einem Blick zu erkennen was durch einen Lambda-Ausdruck in jeder einzelnen Zeile geschieht. Mit diesem Beispiel werden alle Vielfachen von 3 zwischen 0 und 100 ausgegeben:</p>
<p><code>IntStream.range(0, 100)</code><br><code>        .filter(i -&gt; i % 3 == 0)</code><br><code>        .forEach(System.out::println);</code></p>
<p>Richtig praktisch werden solche Lambda und Streams beim lesen von Dateiinhalten:</p>
<p><code>BufferedReader danksagung = new BufferedReader(new FileReader("ebook.txt"))</code><br><code>danksagung.lines()</code><br><code>        .filter(line -&gt; line.toLowerCase().contains("Danksagung"))</code><br><code>        .findFirst()</code><br><code>        .ifPresent(System.out::println);</code></p>
<p>Ab welcher Zeile startet im E-Book die Danksagung? Mit findFrist wird nur die erste Zeile gesucht, in der ein Ergebnis steht, anschliessend wird nicht mehr weiter gesucht, sondern das Ergebnis wird ausgegeben.</p>
<p>Streams sind eine andere Art in Java mit Listen von Daten umzugehen, aber sie sind keinen Ersatz für Collections oder Arrays, eher eine Ergänzung. Streams fehlt nämlich eine Eigenschaft, welche den anderen Datenstrukturen haben: Permanenz. In einer Collection speichern Sie Daten, um bei Bedarf wieder darauf zuzugreifen und zwar so oft sie wollen. Ein Stream dient lediglich der Verarbeitung von Daten. Sie können den Inhalt einen Streams genau einmal auslesen, danach ist er weg und nicht mehr zurückzubekommen. Insofern gleicht ein Stream eher einem Iterator als einer Collection. Wenn Sie auf die Ausgabe der Pipeline nach Belieben wieder zugreifen möchten, dann müssen Sie sie wieder in einer Collection sammeln.</p>
<h3>Intermediäre und terminale Methoden</h3>
<p>Der Unterschied ist, das Intermediäre Methoden wieder ein Stream zurückgeben mit dem man weiterarbeiten kann, terminale Methoden geben einen anderen Ergebnistyp zurück. So entsteht eine Pipeline, die durch die terminale Methode gesteuert wird. Sie "zieht" Daten aus dem Stream und erst durch die terminale Methode werden überhaupt Daten aus dem Stream gelesen. Solange Sie nur intermediäre Methoden aufrufen, passiert im Stream noch nichts.</p>
<p><em>findFrist</em> gibt keinen Stream mehr zurück, sondern ein Optional und if-Present ist eine Methode davon. <em>findFirst</em> ist eine terminale Methode, also eine die am Ende der Stream-Verarbeitung steht. <em>filter</em> dagegen ist eine intermediäre Methode und steht in der Mitte der "Pipeline".</p>
<p>Schauen wir uns das mit dem Beispiel von oben an:</p>
<ul>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Die Methode BufferedReader.lines erzeugt einen Stream&lt;String&gt;. Es werden noch keine Daten gelesen.</span></li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Aus diesem Stream wird mit filter ein neuer Stream erzeugt, der die Filteranweisung verarbeitet. Es werden noch immer keine Daten gelesen.</span></li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Die terminale Methode findFirst wird gerufen. Nun beginnt die Verarbeitung.</span></li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">findFirst liest das erste Element aus dem gefilterten Stream.</span></li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Der gefilterte Stream liest das erste Element des ungefilterten Streams und wertet sein Prädikat line.toLowerCase().contains("Danksagung") aus.</span></li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Die erste Zeile "Einleitung" wird vom Filter zurückgewiesen. Der gefilterte Stream liest die zweite Zeile des ungefilterten Streams und wendet erneut sein Prädikat an. Auch diese Zeile wird zurückgewiesen.</span></li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Erst Zeile Nummer X wird vom Filter akzeptiert. Jetzt gibt der gefilterte Stream seine erste Rückgabe: "Danksagung".</span></li>
<li>findFirst empfängt die Rückgabe vom gefilterten Stream. Es benötigt keine weiteren Ergebnisse. Es wird nur der erste Treffer gesucht, deshalb wird kein weiteres Element aus dem gefilterten Stream gelesen.</li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">findFirst schliesst den gefilterten Stream und gibt das gefundene Ergebnis (richtiger: ein Optional mit dem gefundenen Ergebnis) zurück.</span></li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Was ist wirklich passiert? Es wurden 13 Zeilen aus dem ungefilterten Stream gelesen, davon wurde eine Zeile in den gefilterten Stream weitergeschrieben. Mehr nicht.</span></li>
</ul>
<p>Damit wurde keine Zeile mehr gelesen, als notwendig. Streams sind nicht nur gut darin, Ihre Absichten in Code auszudrücken, sie sind dabei auch noch äusserst effizient.</p>
<h3>Intermediäre Operatoren</h3>
<h5><strong>Sortieren (sort)</strong></h5>
<p>Einen Stream kann nach seiner natürlichen Ordnung sortiert werden, wenn seine Elemente Comparable implementieren, oder mit einem übergebenen Comparator. In allen Fällen bleibt der Inhalt der Datenquelle unverändert. Nachfolgend ein Beispiel, darin wird der heisseste Tag im Jahr gesucht, zuerst wird absteigend nach Temperatur sortiert und dann das erste Element selektiert:</p>
<p><code>tagestemperaturen</code><br><code>        .sorted(Comparator</code><br><code>                .comparing(Tagestemperatur::getTemperatur)</code><br><code>                .reversed())</code><br><code>        .findFirst();</code></p>
<h5>Limitieren (limit)</h5>
<p>Meistens will man nur auf einem teil des Streams arbeiten, z.B. nur auf dem Anfang. Mit limit kann ein Stream auf eine beliebige Anzahl von Elementen beschränkt werden. Auch wenn der darunterliegende Stream mehr Elemente hätte, endet der limitierte Stream, wenn seine Anzahl erreicht ist. Im Beispiel werden die zehn besten Songs aus einer Sammlung sortiert, limitiert und ausgegeben:</p>
<p><code>songs</code><br><code>        .sorted(Comparator.comparing(Song::getSterne).reversed())</code><br><code>        .limit(10)</code><br><code>        .forEach(song -&gt; System.out.println(song.getTitel()));</code></p>
<h5>Überspringen (skip)</h5>
<p>Will man nicht nach einem bestimmen Inhalt suchen, sondern diesen bestimmten Inhalt bewusst überspringen. Folgende Datei soll eingelesen werden:</p>
<p><em>Höchsttemperaturen Basel</em><br><em>Datum;Temperatur</em><br><em>01.3.2021;1</em><br><em>02.3.2021;3</em><br><em>13.3.2021;8</em><br><em>…</em></p>
<p>dabei interessieren uns aber nur die Temperaturen, die ersten zwei Zeilen interessieren uns nicht:</p>
<p><code>daten.lines()</code><br><code>        .skip(2)</code><br><code>        .map(TemperaturMessung::parse)</code><br><code>        ...</code></p>
<h5>Filtern (filter)</h5>
<p>Man übergibt ihr ein Predicate und nur die Elemente, für die das Predicate true liefert, werden im Stream weitergereicht:</p>
<p><code>kandidaten</code><br><code>        .filter(k -&gt; k.getHaarfarbe().equals("rot") </code><br><code>                &amp;&amp; k.getAugenfarbe().equals("grün"))</code><br><code>        .forEach(k -&gt; sprichAn(k));</code></p>
<h5>Einmaligkeit (distinct)</h5>
<p>Wenn in einem Stream Duplikate entfernt werden sollen, kann das mit distinct sichergestellt werden. Damit merkt sich der Strom alle Elemente, die bereits einmal vorkamen und gibt sie kein zweites Mal zurück. Bei Streams von Objekten wird Gleichheit mit equals bestimmt. Achtung: distinct ist eine Operation mit Zustand und kann für lange Streams sehr viel Speicher belegen.</p>
<p><code>kontakte</code><br><code>        .distinct()</code><br><code>        .count();</code></p>
<h5>Abbilden</h5>
<p>Das sind alle Operationen, die aus den Eingabewerten etwas berechnen und als Ausgabestrom wieder ausgeben:</p>
<p><code>personen</code><br><code>        .map(Person::getName)</code><br><code>        .forEach(System.out::println);</code></p>
<p>Mit der map-Methode ist der Ausgabe-Stream wieder ein Stream von Objekten; wenn das Ergebnis der Function ein primitiver Typ ist, wird er dazu in den passenden Wrapper konvertiert. Wenn man deinen Stream von primitiven Typen als Ausgaben benötigt, stehen dafür die Methoden <em>mapToInt</em>, <em>mapToLong</em> und <em>mapToDouble</em> zur Verfügung.</p>
<p>Etwas komplizierter ist die Methode flatMap und ihre primitiven Gegenstücke. Sie erwarten als Parameter eine Funktion, die aus jedem Eingabeelement einen Stream erzeugt. Die Ausgabe von flatMap ist ein Stream, in dem die Elemente aller Streams jeweils nacheinander zu einem Ausgabe Stream zusammengefasst sind. Als Beispiel: Das Stadtfest in Ihrer Stadt. Es war eine Anmeldung erforderlich und von jeder Anmeldung wird erwartet, dass die gesamte Familie mitkommt. Anmeldungen sind in einem Objekt vom typ Person gespeichert, das den Namen der Person enthält, seinen oder ihren Partner als weiteres Person-Objekt und die Kinder als Liste von Personen. Angemeldet sind:</p>
<ul>
<li>Hans Fischer mit Partner Frieda Fischer und den Kindern Fritz, Max und Lisa</li>
<li>Ida mit Partner Martin</li>
<li>Max Müller mit seinen Kindern Moritz und Peter</li>
</ul>
<p>Von der ersten Anmeldung ausgehend soll nun eine Liste aller erwarteten Gäste ausgegeben werden:</p>
<p><code>anmeldungen</code><br><code>        .flatMap(p -&gt; Stream.concat(</code><br><code>                Stream.of(p, p.getPartner()), </code><br><code>                p.getKinder().stream()))</code><br><code>        .filter(p -&gt; p != null)</code><br><code>        .map(Person::getName)</code><br><code>        .forEach(System.out::println);</code></p>
<p>Mit flatMap ist die Liste schnell erstellt, aber was genau passiert, ist auch mit Lambda-Ausdrücken nicht sofort ersichtlich:</p>
<ul>
<li>Mit Stream.of wird ein Stream erzeugt, der die person selbst und ihren Partner enthält. Dank Varargs können Stream.of einfach alle Elemente übergeben werden, die der so erzeugt Stream enthalten soll.</li>
<li>Aus der Liste von Kindern wird ein weiterer Stream erzeugt. Da die Kinder in einer Collection gespeichert sind, kann da smit der stream-Methode erreicht werden.</li>
<li>Diese beiden Stream werden mit Stream.concat zusammengesetzt. Die Methode gibt einen Stream zurück, der das Erste aller Elemente des ersten übergebenen Streams und danach allen Elemente des zweiten übergebenen Streams enthält.</li>
<li>flatMap wird für jede Person aus <em>anmeldungen</em> gerufen, intern werden dadurch drei Stream erzeugt: [Hans Fischer, Frieda Fischer, Fritz, Max, Lisa][Ida, Martin][Max Müller, null, Moritz und Peter]. Da Max Müller keinen Partner (mehr) hat, resultiert aus p.getPartner() ein null-Wert; dieser wird von der späteren filter-Anweisung wieder entfernt werden.</li>
<li>flatMap gibt aber nicht einen Stream pro Eingabe zurück (das käme bei map heraus), sondern nur einen langen Stream. Daher auch der Name flatMap: Anstatt einen Stream von Streams auszugeben, ist die Ausgabe flach. Der so erzeugte Stream enthält also: [Hans Fischer, Frieda Fischer, Fritz, Max, Lisa, Ida, Martin, Max Müller, null, Moritz und Peter]</li>
</ul>
<h5>Spicken (peek)</h5>
<p>peek gibt genau denselben Stream aus, der auch eingegeben wurde, führt aber für jedes Element einen Consumer aus. Der Inhalt des Streams wird nicht verändert. Mit peek können Sie einem Stream bei der Arbeit zuschauen, was insbesondere bei Fehlersuche hilfreich ist:</p>
<p><code>danksagung.lines()</code><br><code>        .peek(line -&gt; System.out.println("Ungefiltert " + line))</code><br><code>        .filter(line -&gt; line.toLowerCase().contains("Danksagung"))</code><br><code>        .peek(line -&gt; System.out.println("Gefiltert " + line))</code><br><code>        .findFirst()</code><br><code>        .ifPresent(System.out::println);</code></p>
<p>peek kann auch verwendet werden, um beispielsweise bei Anmeldungen Bestätigungen zu versenden:</p>
<p><code>anmeldungen</code><br><code>        .peek(p -&gt; bestaetigeAnmeldung(p))</code><br><code>        .flatMap(p -&gt; Stream.concat(Stream.of(</code><br><code>                p, p.getPartner()), </code><br><code>                p.getKinder().stream()))</code><br><code>        .filter(p -&gt; p!= null)</code><br><code>        .map(Person::getName)</code><br><code>        .forEach(System.out::println);</code></p>
<h3>Terminale Operatoren</h3>
<h5>Alle Elemente verarbeiten</h5>
<p>Diese Methode führt für alle Elemente, die am Ende in einem Stream enthalten sind, diesele Operation aus. forEach ist als Beispiel zu nennen. Sie führt den übergebenen Consumer für jedes Element des Streams aus. </p>
<h5>Finden</h5>
<p>Wenn aus einem Stream nicht alle Elemente verarbeitet werden solle, sondern nur ein einzelnen benötigt wird, gibt es dafür findFirst oder findAny:</p>
<p><code>Optional&lt;Student&gt; gut = studenten</code><br><code>        .filter(student -&gt; student.getNotendurchschnitt() == 5.0)</code><br><code>        .findAny();</code></p>
<p>Der unterschied zwischen den beiden Methoden ist, dass findFirst garantiert das erste Element zurückgibt, findAny nur irgendein Element. Dieser Unterschied kommt bei paralleler Verarbeitung zum Tragen, wo das erste gefunden Element nicht notwendig das erste aus dem Stream ist. findFirst stellt in dieser Situation sicher, dass wirklich das erste Element des Stream ausgegeben wird.</p>
<p>Beide Methoden geben ein Optional-Objekt zurück. Grob gesagt handelt es sich um einen Umschlag, der ein Objekt ungleich null enthalten oder auch leer sein kann. So wird auch, wenn kein Ergebnis gefunden wurde, ein Objekt zurückgegeben, nicht direkt ein null-Wert. Dadurch können Sie an dem zurückgegeben en Objekt immer weitere Methoden aufrufen und müssen nicht auf null prüfen, was. in der Aufrufkette der Fluent API nicht möglich wäre. Stattdessen können Sie diese Prüfung in die Aufrufkette integrieren:</p>
<p><code>studenten</code><br><code>        .filter(student -&gt; student.getNotendurchschnitt() == 5.0)</code><br><code>        .findAny()</code><br><code>        .ifPresent(s -&gt; verarbeiteGutenStudenten(s));</code></p>
<p>Das an ifPresent übergebene Lambda wird nur ausgeführt, wenn das von findAny zurückgegebene Optional ein Ergebnis enthält.</p>
<h5>Prüfen</h5>
<p>Nur um zu prüfen, ob der Stream Elemente enthält, die einem bestimmten Kriterium entsprechen, ohne diese Elemente zurückzugeben, gibt es drei boolesche Methoden. anyMatch, prüft, ob irgendein Element des Streams zum übergebenen Predicate passt, allMatch prüft, ob alle Elemente passen, und noneMatch schliesslich, ob keines der Elemente passt.</p>
<p><code>if (studenten.anyMatch(student -&gt; </code><br><code>        student.getNotendurchschnitt() == 6.0)){</code><br><code>    …            </code><br><code>}</code></p>
<h5>Reduzieren</h5>
<p>Mit Streams können Sie auch einen einzelnen Wert berechnen lassen, der den Stream zusammenfasst. Der Inhalt wird auf diesen einen Wert reduziert, daher auch der Name der Methode für diese Operatoren: reduce.</p>
<p><code>int gesamtlaenge = songs</code><br><code>        .mapToInt(Song::getLaengeInSekunden)</code><br><code>        .reduce(0, (x, y) -&gt; x+y);</code></p>
<p>Die reduce-Methode funktioniert, indem nacheinander (oder sogar parallel) alle Elemente des Streams durch die übergebene Funktion mit einem Akkumulator verknüpft werden. Der Akkumulator wird mit dem übergebenen Neutralwert der Verknüpfung vorbelegt. Im Beispiel werden also, von einem Wert 0 ausgehend, die Länge aller Songs im Stream addiert, um die Gesamtlänge zu berechnen.</p>
<p>Sie müssen keinen Neutralwert übergeben, dann erhält der Akkumulator anfangs das erste Element (sofern vorhanden)m due erste Verknüpfung geschieht mit dem zweiten Element, und das Ergebnis der reduce-Operation ist Optional. Im Beispiel soll der längste Songs gefunden werden:</p>
<p><code>Optional&lt;Song&gt; laengsterSong = songs.reduce((x, y) -&gt;</code><br><code> x.getLaengeInSekunden() &gt; y.getLaengeInSekunden() ? x : y);</code></p>
<p>Der ternäre Fragezeichen-Operator gibt immer den längeren der beiden Songs zurück, am Ende bleibt im Akkumulator der längste stehen.</p>
<p>Einige häufigt reduce-Operatoren sind schon als eigene Methoden implementiert:</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td style="width: 49.9288%;"><strong>Methode</strong></td>
<td style="width: 49.9288%;"><strong>Funktion</strong></td>
</tr>
<tr>
<td style="width: 49.9288%;">count</td>
<td style="width: 49.9288%;">zählt die Elemente im Stream</td>
</tr>
<tr>
<td style="width: 49.9288%;">(nur primitive Streams) sum</td>
<td style="width: 49.9288%;">summiert alle Zahlen im Stream</td>
</tr>
<tr>
<td style="width: 49.9288%;">(nur primitive Streams) min / max</td>
<td style="width: 49.9288%;">das kleinste, bzw. grösste Element</td>
</tr>
<tr>
<td style="width: 49.9288%;">(nur primitive Streams) average</td>
<td style="width: 49.9288%;">Durchschnitt aller Elemente</td>
</tr>
</tbody>
</table>
<p>Komplexere Methoden, die aus einem Stream wieder andere Typen gewinnen, um z.B. einen Stream wieder in eine Liste umzuwandeln, werden mit Collections umgesetzt.</p>
<p> </p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Lambda Funktionale Interfaces</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/lambda-funktionale-interfaces.html"/>
        <id>https://www.finecloud.ch/lambda-funktionale-interfaces.html</id>
            <category term="softwareentwicklung"/>
            <category term="lambda"/>
            <category term="java"/>
            <category term="interface"/>
            <category term="functional"/>
            <category term="dev"/>

        <updated>2022-05-30T16:46:59+02:00</updated>
            <summary>
                <![CDATA[
                    Lambda Interfaces sind häufig benötigte Lambda-Ausdrücke, die Teil des JDKs sind und damit nicht in jedem Projekt wieder neu angelegt werden müssen. Zum Beispiel kann mit dieser Methode eine Summe aus Objekten berechnet werden: public static &lt;T&gt; long summiere(List&lt;T&gt; tees, ToIntFunction&lt;T&gt; func){ long result =&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Lambda Interfaces sind häufig benötigte Lambda-Ausdrücke, die Teil des JDKs sind und damit nicht in jedem Projekt wieder neu angelegt werden müssen.</p>
<p>Zum Beispiel kann mit dieser Methode eine Summe aus Objekten berechnet werden:</p>
<p><code>public static &lt;T&gt; long summiere(List&lt;T&gt; tees, ToIntFunction&lt;T&gt; func){</code><br><code>    long result = 0;</code><br><code>    for (T tee : tees){</code><br><code>        result += func.applyAsInt(tee);</code><br><code>    }</code><br><code>    return result;</code><br><code>}</code></p>
<p>Alle Interfaces die Lambda-Ausdrücke ermöglichen, sind Bestandteil des Packages java.util.function. Darin sind rund 40 Interfaces enthalten. Eine konsequente Namenskonvention hilft den Überblick zu behalten. Dabei werden die Interfaces grundlegend nach der Form benannt, also nach Parametern und Rückgabewerten. Diese grundlegenden Interfaces arbeiten mit Objekten. Für Interfaces, die dieselbe Operation für Primitive bereitstellen, wird der Name des primitiven Typs vorangestellt:</p>
<ul>
<li>Function&lt;T, R&gt; erwartet ein Objekt vom Typ T als Parameter und gibt ein Objekt vom Typ R zurück.</li>
<li>ToIntFunction&lt;T&gt; erwartet ein Objekt vom Typ T als Parameter und gibt einen int-Wert zurück.</li>
<li>DoubleToIntFunction erwartet einen double-Wert als Parameter und gibt einen int-Wert zurück.</li>
</ul>
<p>Nicht alle möglichen Kombinationen stehen zur Verfügung, aber die am häufigsten gebrauchten sind da. Nachfolgend schauen wir uns die grundlegenden Formen von funktionalen Interfaces an.</p>
<h3>Function</h3>
<p>Funktionsobjekte entsprechen in etwa der mathematischen Definition von einstelligen Funktionen: Sie bilden einen Wert auf einen anderen ab. Eine einfache Function ist eine Abbildung von einem Objekt auf ein anderes Objekt, eine ToIntFunction eine Abbildung von einem Objekt auf einen int-Wert usw.</p>
<p>Im vorherigen Codebeispiel haben wir eine Anwendung für ToIntFuntion gesehen, dort werden Objekte auf einen Int-Wert abgebildet, der anschliessend zu einer laufenden Summe addiert wird. Auch die Methode Comparator.comparing erwartet ein Function-Objekt als Parameter:</p>
<p><code>Comparator&lt;Song&gt; nachTitel = Comparator.comparing(s -&gt; s. getTitel());</code></p>
<p>In diesem Beispiel werden Songs nach ihrem Titel sortiert, indem jeder Song als einen String, sein Titel abbildet und anschliessend nach der natürlichen Reihenfolge dieser Strings sortiert wird. Genau in diesem Fall können Sie auch eine Methodenreferenz verwenden: (da der Lambda-Ausdruck lediglich aus einem parameterlosen Methodenaufruf besteht):</p>
<p><code>Comparator&lt;Song&gt; nachTitel = Comparator.comparing(Song::getTitel);</code></p>
<p>Es gibt aber auch Funktionen deren Eingabe- und Ausgabetypen identisch sind, diese werden als Unary-Operator bezeichnet. So gibt es zum Beispiel den IntUnaryOperator, der einen int-Wert auf einen anderen int-Wert abbildet.</p>
<h3>Predicate</h3>
<p>Funktionen bei denen der Eingabewert immer auf eine boolean-Ausgabe abgebildet wird, werden Prädikate genannt. Predicate könnte also auch ToBooleanFunction heisst, hat aber wegen seiner besonderen Bedeutung einen eigenen Namen erhalten. Predicate sind besonders wichtig zum Filtern. Damit kann ein Stream mit einem Predicate-Objekt gefiltert werden, so dass nur noch die Elemente enthalten sind, die das Prädikat erfüllen, für die der Lambda-Ausdruck also true zurückgibt:</p>
<p><code>List&lt;Song&gt; songs = …;</code><br><code>songs.stream().filter(s -&gt; s. getSterne() == 5).count();</code></p>
<p>Doch damit nicht genug, es ist weiter möglich Predicate mit logischen Operatoren AND, OR und NOT anzuwenden und somit mehrere Predicate zu einem einzigen zu verknüpfen:</p>
<p><code>private static Predicate&lt;Song&gt; baueSuchPredicate(String suchtitel,</code><br><code> String suchinterpret, int suchsterne) {</code><br><code>    Predicate&lt;Song&gt; filter = (s-&gt;true);</code><br><code>    if (suchtitel != null){</code><br><code>        filter = filter.and(s -&gt; </code><br><code>                s.getTitel().startsWith(suchtitel));</code><br><code>    }</code><br><code>    if (suchinterpret != null){</code><br><code>        filter = filter.and(s -&gt; </code><br><code>                s.getInterpret().startsWith(suchinterpret));</code><br><code>    }</code></p>
<p><code></code><code> if (suchsterne &gt; 0){</code><br><code>        filter = filter.and(s -&gt; s. getSterne() &gt;= suchsterne);</code><br><code>    }</code><br><code>    return filter;</code><br><code>}</code></p>
<p>Die Initialisierung mit Predicate&lt;Song&gt; filter = (s-&gt;true) wird deshalb so vorgenommen, damit es ein erstes Objekt gibt, an dem Sie überhaupt and rufen können. Anderenfalls müssten Sie bei jedem Suchattribut wieder prüfen, ob es schon einen Filter gibt, falls ja, and rufen, und falls nein, einen erzeugen.</p>
<h3>Consumer</h3>
<p>Dabei handelt es sich um Funktionen ohne Rückgabewert. Sie erwarten einen Parameter, den sie verarbeiten, liefern aber kein Ergebnis:</p>
<p><code>public static void main(String[] args) throws IOException{</code><br><code>    liesStrings((s) -&gt; System.out.println(s));</code><br><code>}</code><br><code>    </code><br><code>public static void liesStrings(Consumer&lt;String&gt; sink) throws IOException{</code><br><code>    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));</code><br><code>    String line;</code><br><code>    while (!"".equals(line = in.readLine())){</code><br><code>        sink.accept(line);</code><br><code>    }</code><br><code>}</code></p>
<p>Die Methode liesStrings liest so lange beliebig viele Strings von der Standardeingabe, bis eine leere Zeile gelesen wird und gibt jede gelesene teile an den übergebenen Consumer&lt;String&gt; weiter. Im Beispiel werden die gelesenen Strings einfach wieder ausgegeben, aber dieselbe Methode könnte eine Eingabe auch in einer Liste sammeln, oder jede Zeile als Kommando interpretieren:</p>
<p><code>//Zeilen in eine Liste lesen</code><br><code>List&lt;String&gt; zeilen = new ArrayList&lt;&gt;();</code><br><code>liesStrings(zeilen::add);</code><br><code>//Zeilen als Kommandos ausführen</code><br><code>liesStrings(this::fuehreKommandoAus);</code></p>
<h3>Supplier</h3>
<p>Supplier ist das Gegenstück zum Consumer, sie haben keine Parameter, geben aber etwas zurück.</p>
<p>Welchen Sinn kann ein solcher Aufruf</p>
<p><code>zeigeNachricht(() -&gt; entschluessleNachricht(nachricht))</code><br><br>gegenüber dem folgenden, einfacheren haben?<br><br><code>zeigeNachricht(entschluessleNachricht(nachricht))</code><br><br>In diesem Beispiel können Sie unnötigen Rechenaufwand vermeiden. Die Methode zeigeNachricht stammt aus einem fiktiven E-Mail-Client, der Verschlüsselung beherrscht. Ihre Implementierung könnte so aussehen:<br><br><code>public zeigeNachricht(String nachricht){</code><br><code>    if (zeigeVorschau)</code><br><code>        System.out.println(nachricht);</code><br><code>}</code></p>
<p>Im Beispiel wird die entschlüsselte Nachricht an die Methode übergeben, obwohl noch nicht klar ist, ob sie überhaupt benötigt wird. Wenn zeigeVorschau false ist, dann wird der Parameter ignoriert und die potenziell teure Entschlüsselung war umsonst.</p>
<p><code>public zeigeNachricht(Supplier&lt;String&gt; nachricht){</code><br><code>    if (zeigeVorschau)</code><br><code>        System.out.println(nachricht.get());</code><br><code>}</code></p>
<p>Nicht so in diesem Fall. Die Nachricht wird erst dann entschlüsselt, wenn am Supplier get gerufen wird, solange get nicht gerufen wird, wird die Nachricht nicht entschlüsselt.</p>
<h3>BiFunction, BiPredicate, BiConsumer</h3>
<p>Zu diesen Funktionen gibt es jeweils noch eine Variante mit einem vorangestellten Bi-. Diese unterscheiden sich von ihren einfachen Gegenstücken dadurch, dass sie zwei Parameter statt einem nehmen. Ein BiPredicate bildet also zum Beispiel zwei Objekte auf einen boolean-Wert ab. Funktionen die zwei gleichartige Wert auf einen dritten Wert desselben Typs abbilden heissen BinaryOperator.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Lambda-Ausdrücke Teil 2</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/lambda-ausdruecke-2.html"/>
        <id>https://www.finecloud.ch/lambda-ausdruecke-2.html</id>
            <category term="softwareentwicklung"/>
            <category term="lambda"/>
            <category term="java"/>
            <category term="dev"/>

        <updated>2022-05-29T15:35:47+02:00</updated>
            <summary>
                <![CDATA[
                    Im ersten Teil zum Thema Lambda-Ausdrücke haben wir gelernt was Lambda-Ausdrücke sind und wie man diese verwenden kann. Im zweiten Teil schauen wir nun hinter die Kulissen, wie Lambda-Ausdrücke funktionieren. Zentral zum Verständnis, wie Lambda-Ausdrücke in Java funktionieren, ist der Begriff des funktionalen Interface. Das&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Im ersten Teil zum Thema Lambda-Ausdrücke haben wir gelernt was Lambda-Ausdrücke sind und wie man diese verwenden kann. Im zweiten Teil schauen wir nun hinter die Kulissen, wie Lambda-Ausdrücke funktionieren.</p>
<p>Zentral zum Verständnis, wie Lambda-Ausdrücke in Java funktionieren, ist der Begriff des <em>funktionalen Interface</em>. Das ist ein Interface, das nur eine Methode definiert. Das war bereits vor der Lambda Einführung eine übliche Möglichkeit, in Java Funktionalität als Parameter zu übergeben.</p>
<p><code>Arrays.sort(einArray, new Comparator(){</code><br><code>    public int compareTo(Object o1, Object o2){…}</code><br><code>});</code></p>
<p>Comparator ist ein funktionales Interface, es deklariert nur die Methode compareTo. Aber ein Lambda-Ausdruck kann überall dort, wo ein funktionales Interface als Parametertyp angeben wird eingesetzt werden. Das heisst auch als Comparator:</p>
<p><code>Arrays.sort(songs, (song1, song2) -&gt; </code><br><code> song1.getLaengeInSekunden() - song2.getLaengeInSekunden())</code></p>
<p>Das funktioniert mit allen funktionalen Interfaces, auch eigene. Wenn Sie ein Interface deklarieren, das nur eine Methode enthält, dann können Sie, um dieses Interface zu implementieren, auch Lambda-Ausdrücke verwenden.</p>
<h3>Closures</h3>
<p>Oft wird für Lambda-Ausdrücke auch der Begriff Closure verwendet. Die beiden gehören untrennbar zusammen, sind aber nicht dasselbe.</p>
<p>Ein Lambda-Ausdruck ist definiert als eine anonyme Funktion. Er erfüllt dieselbe Aufgabe wie eine Methode, hat aber keinen Namen.</p>
<p>Ein Closure hingegen ist ein Bündel aus einer Funktion und der Umgebung, aus der heraus diese Funktion aufgerufen wurde. Mit Umgebung sind hier die lokalen Variablen gemeint welche zum Zeitpunkt des Aufrufs im Scope liegen. Das beim Erzeugen der anonymen Objektinstanz oder der Lambda-Instanz eine Closure gebildet wird, erlaubt es, auf die Werte der lokalen Variablen auch dann noch zuzugreifen, wenn sie schon nicht mehr im Scope liegen:</p>
<p><code>public static void main(String[] args) throws Exception {</code><br><code>    IntSupplier test = erzeugeClosure();</code><br><code>    new Thread(() -&gt; System.out.println(test.getAsInt())).start();</code><br><code>}</code><br><code>public static IntSupplier erzeugeClosure() {</code><br><code>    int wert = 123;</code><br><code>    return (() -&gt; wert);</code><br><code>}</code></p>
<p>Die Funktion <em>erzeugeClosure</em> gibt eine Instanz des funktionalen Interface <em>IntSupplier</em> zurück, die als Lambda angegeben ist. Die <em>main</em>-Methode führt diese zurückgegebene Instanz in einem neuen Thread aus, indem sie ihre <em>getAsInt</em>-Methode ruft. Obwohl der Wert dieser Variable zu diesem Zeitpunkt nicht mehr im Scope liegt, kommt es zur Ausgabe "123". Das ist möglich, weil die Variable in der Closure, die für den Lambda-Ausdruck erzeugt wird, noch vorhanden ist. <strong>Der Lambda-Ausdruck ist das, was Sie in Ihrem Code niederschreiben. Erst zur Laufzeit wird daraus und aus der Ausführungsumgebung eine Closure.</strong></p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Lambda-Ausdrücke Teil 1</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/lambda-ausdruecke.html"/>
        <id>https://www.finecloud.ch/lambda-ausdruecke.html</id>
            <category term="softwareentwicklung"/>
            <category term="lambda"/>
            <category term="java"/>
            <category term="dev"/>

        <updated>2022-05-29T15:04:11+02:00</updated>
            <summary>
                <![CDATA[
                    Seit Java 8 können mit Lambda Expressions Funktionen komfortabler, kürzer und lesbarer ausgedrückt werden. Nachfolgend ein Beispiel von Java Code. Dieses Stück Code sucht aus Ihrer Musiksammlung die 100 längsten Songs heraus, die Sie mit mehr als vier Sternen bewertet haben und deren Interpret Ihnen&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Seit Java 8 können mit Lambda Expressions Funktionen komfortabler, kürzer und lesbarer ausgedrückt werden.</p>
<p>Nachfolgend ein Beispiel von Java Code. Dieses Stück Code sucht aus Ihrer Musiksammlung die 100 längsten Songs heraus, die Sie mit mehr als vier Sternen bewertet haben und deren Interpret Ihnen nicht bekannt ist, und berechnet die Gesamtlänge dieser Songs:</p>
<p><code>List&lt;Song&gt; songs = …;</code><br><code>int sekunden = 0;</code><br><code>Sekunden</code><br><code>Collections.sort(songs, new Comparator&lt;Song&gt;(){</code><br><code>    @Override</code><br><code>    public int compare(Song o1, Song o2) {</code><br><code>        return o1.getLaengeInSekunden() - o2. getLaengeInSekunden ();</code><br><code>    }</code><br><code>});</code><br><code>int zaehler = 0;</code><br><code>for (Song song : songs){</code><br><code>    if (song.getSterne() &gt; 4 </code><br><code>            &amp;&amp; ("Unbekannter Künstler".equals(song.getInterpret())){</code><br><code>        sekunden += song.getLaengeInSekunden();</code><code></code><br><code>        if (++zaehler &gt; 100) break;</code><br><code>    }</code><br><code>}</code></p>
<p>Nachfolgend der Java Code der den gleichen Zweck erfüllt, aber Lambda Ausdrücke verwendet:</p>
<p><code>int sekunden = songs.stream()</code><br><code>    .filter(song -&gt; "Unbekannter Künstler".equals(song.getInterpret()))</code><br><code>    .filter(song -&gt; song.getSterne() &gt; 4)</code><br><code>    .sorted(Comparator.comparing(Song::getLaengeInSekunden).reversed())</code><br><code>    .limit(100)</code><br><code>    .mapToInt(Song::getLaengeInSekunden)</code><br><code>    .sum();</code></p>
<p>Die Vorteile liegen auf der Hand: Abgesehen von der Zeilen und Codelänge ist der Code auch viel einfach verständlich, schnell lässt sich erkennen, was der Code bewirkt. In den ersten beiden Zeilen wird die Liste gefiltert (filter), danach sortiert (sorted), auf die 100 ersten Ergebnisse beschränkt (limit), jeder Song auf sein int-Feld laengeInSekunden abgebildet (mapToInt) und von den Längen schliesslich die Summe (sum) berechnet</p>
<h3>Was sind Lambda-Ausdrücke?</h3>
<p>Es handelt sich dabei um Javas Sprachmittel, um Funktionen auszudrücken, im Gegensatz dazu stehen die prozedualen Konstrukte wie Verzweigungen und Schleifen, mit denen der Programmierablauf dargestellt wird. Lambda-Ausdrücke erlauben es zusammen mit entsprechenden APIs im Code nur das Wesentliche zu schreiben, ohne dabei jedes Mal das Übliche wiederholen zu müssen. Das Wesentliche ist eine Liste von Songs zu filtern. Das Übliche wäre in diesem Fall, über eine Liste zu iterieren und jedes Element zu prüfen.</p>
<p>Ohne Lambda-Ausdrücke wird der Code länger, wenige gut lesbar und Fehleranfälliger, denn in Schleifen und Prüfungen schleichen sich gerne Fehler ein.</p>
<h3>Die Lambda-Syntax</h3>
<p>Lambda-Ausdrücke sind auf den ersten Blick als solche erkennbar durch den Pfeil -&gt;, der vorkommen muss und in Java keine andere Bedeutung hat.</p>
<p><code>(Song song) -&gt; {</code><br><code>    return "Unbekannter Künstler".equals(song.getInterpret());</code><br><code>}</code></p>
<p>Links vom Pfeil stehen die Parameter und rechts vom Pfeil steht, was mit diesen parametern geschehen soll. Mehrere Parameter werden, genau wie bei einer Methodendeklaration auch durch Kommas getrennt.</p>
<p>Doch es geht noch kürzer. Es dürfen auch die Parametertypen wegfallen:</p>
<p><code>(song) -&gt; {</code><br><code>    return "Unbekannter Künstler".equals(song.getInterpret());</code><br><code>}</code></p>
<p>Der Java-Compiler ist inzwischen sehr gut darin, Typen aus dem Kontext zu erkennen. Da wir mit einer List&lt;Song&gt; arbeiten und daraus ein Stream&lt;Song&gt; wird, ist für den Compiler klar, dass der Typ des Rückgabewerts auch ein Song sein muss.</p>
<p>Weiter darf, wenn der Lambda-Ausdruck nur ein Parameter benötigt die Klammer um den Parameter herum entfallen:</p>
<p><code>song -&gt; {</code><br><code>    return "Unbekannter Künstler".equals(song.getInterpret());</code><br><code>}</code></p>
<p>Wenn der Ausdruck allerdings keine Parameter hat, muss die Klammer wieder hin. Beispielsweise kann () -&gt; 3 ein gültiger Lambda-Ausdruck sein, der keine Parameter erwartet und die Zahl 3 zurückgibt.</p>
<p>Als letzte Verkürzungsregel darf, wenn ein Rumpf eines Ausdrucks nur aus einem Ausdruck besteht, also einer einzigen Anweisung, die zu einem Wert ausgewertet wird (Vergleich, Berechnung oder Methodenaufruf) nur der Wert-Ausdruck selbst angegeben werden, ohne geschweifte Klammern, ohne Semikolon und ohne return:</p>
<p><code>song -&gt; "Unbekannter Künstler".equals(song.getInterpret())</code></p>
<p>Dabei gibt es aber keine Zwischenschritte, entweder man gibt den Ausdruck wie im letzten Beispiel an, oder man muss den Ausdruck mit geschweiften Klammern, Semikolon und return angeben. Natürlich ist die kürzeste Version anzustreben. Deshalb sollte immer auf die Blockschreibweise verzichtet werden, ausser man hat mehr als ein Wert-Ausdruck, beispielsweise bei einem if-Statement, hier müssen die äusseren Klammern und Returns geschrieben werden:</p>
<p><code>(s1, s2) -&gt; {</code><br><code>    if (aufsteigend){</code><br><code>        return s1.getLaengeInSekunden() - s2.getLaengeInSekunden();</code><br><code>    } else {</code><br><code>        return s2.getLaengeInSekunden() - s1.getLaengeInSekunden();</code><br><code>    }</code><br><code>}</code></p>
<p>Als letzte Spezialität in diesem Artikel gehe ich auf die Variable aufsteigend ein. Genau wie anonyme innere Klassen können Lambdas auf lokale Variabeln ihrer Umgebung zugreifen. Diese lokalen Variablen müssen nicht als final deklariert werden, müssen aber also solche behandelt werden. Das heisst, es reicht aus wenn ihnen im Lambda-Ausdruck oder danach kein neuer Wert mehr zugewiesen wird.</p>
<h3>Methodenreferenz</h3>
<p>Wenn ein Lambda-Ausdruck nur am einzigen übergebenen Parameter eine Methode aufruft und deren Rückgabewert weitergibt, dann kann statt des Lambda-Ausdrucks eine Methodenreferenz angeben werden. Die nachfolgenden Aufrufe haben die gleiche Wirkung:</p>
<p><code>Comparator.comparing(song -&gt; song.getSterne());</code><br><code>Comparator.comparing(Song::getSterne);</code></p>
<p>Methodenreferenzen erkennt man am doppelten Doppelpunkt. Davor steht die Klasse, dahinter die Methode. Wichtig ist, dass man bei der Methodenreferenz keine Klammern nach dem Methodenamen setzt. Das Beispiel von oben ist eine <em>ungebundene Referenz</em>: Sie bezeichnet nicht die getSterne-Methode eines bestimmten Objekts, sondern kann auf beliebige Objekte der Klasse Song angewendet werden. Ist vor dem doppelten Doppelpunkt keine Klasse, sondern eine Objektreferenz, dann ist die Methodenreferenz gebunden und meint immer die Methode dieses einen Objekts.</p>
<p><code>Musicplayer player = new Musicplayer();</code><br><code>songs</code><br><code>        .filter(s -&gt; s. getSterne() == 5)</code><br><code>        .forEach(player::play);</code></p>
<p>Die Referenz player::play meint immer die play-Methode des Musicplayer, den die Variable player referenziert. Mit Lambda-Ausdrücken, aber ohne Methodenreferenz, sähe das Beispiel dann so aus:</p>
<p><code>Musicplayer player = new Musicplayer();</code><br><code>songs</code><br><code>        .filter(s -&gt; s. getSterne() == 5)</code><br><code>        .forEach(s -&gt; player.play(s));</code></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Java Maps</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/java-die-pecs-regel.html"/>
        <id>https://www.finecloud.ch/java-die-pecs-regel.html</id>
            <category term="softwareentwicklung"/>
            <category term="maps"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="collection"/>

        <updated>2022-05-28T20:17:04+02:00</updated>
            <summary>
                <![CDATA[
                    Maps werden auf Deutsch auch als assoziative Arrays bezeichnet. Ein Array ordnet ein Objekt einer Zahl zu, dem Index. Eine Map ordnet ein Objekt, den Wert, einem anderen Objekt zu, dem Schlüssel. Damit ist es möglich Zuordnungen von einem beliebigen Typ zu einem beliebigen anderen&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Maps werden auf Deutsch auch als <em>assoziative Arrays</em> bezeichnet. Ein Array ordnet ein Objekt einer Zahl zu, dem Index. Eine Map ordnet ein Objekt, den Wert, einem anderen Objekt zu, dem Schlüssel. Damit ist es möglich Zuordnungen von einem beliebigen Typ zu einem beliebigen anderen Typ vorzunehmen. Häufig werden Strings als Schlüssel verwendet, es kann aber jeder Objekttyp als Schlüssel dienen.</p>
<p>Eine Map besteht aus zwei Typparameter, den ersten für den Schlüssel und den zweiten für den Wert. Die Map wordCount ist eine Zuordnung von einem String-Schlüssel zu einem Integer-Wert, es ist die am häufigsten verwendete Implementierung von Map:</p>
<p><code>private Map&lt;String, Integer&gt; wordCounts = new HashMap&lt;&gt;();</code><br><code>  private void count(InputStream source){</code><br><code>    try(Scanner scan = new Scanner(source)){</code><br><code>        scan.useDelimiter("[^\\p{IsAlphabetic}]+");</code><br><code>        while (scan.hasNext()){</code><br><code>            String word = scan.next().toLowerCase();</code><br><code>            totalCount++;</code><br><code>            wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);</code><br><code>        }</code><br><code>    }    </code><br><code>}</code></p>
<p>Die put-Methode fügt ein Element hinzu (falls bereits ein Element zugeordnet ist, wird es Überschrieben), die get-Methode gibt den einem Schlüssel zugeordneten Wert zurück. GetOrDefault hat dieselbe Funktion, nur das zusätzlich ein Default-Wert übergeben werden kann, der zurückgegeben wird, falls der angegebene Schlüssel nicht in der Map enthalten ist.</p>
<p>Hier ein weiteres Beispiel einer Geburtstagsliste:</p>
<p><code>public class Geburtstagsliste {</code><br><code>    private Map&lt;String, LocalDate&gt; geburtstage = new TreeMap&lt;&gt;();</code><br><code>    </code><br><code>    public void fuegeGeburtstagHinzu(String name, LocalDate geburtstag){</code><br><code>        geburtstage.put(name, geburtstag);</code><br><code>    }</code><br><code>    </code><br><code>    public LocalDate findeGeburtstag(String name){</code><br><code>        return geburtstage.get(name);</code><br><code>    }</code><br><code>    </code><br><code>    public void schreibeGeburtstage(){</code><br><code>        for(Map.Entry&lt;String, LocalDate&gt; entry : geburtstage.entrySet()){</code><br><code>            System.out.println(entry.getKey() + ": " + entry.getValue());</code><br><code>        }</code><br><code>    }</code><br><code>}</code></p>
<p>Ein weiteres Feature von Map ist, dass man über eine Map iterieren kann:</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td style="width: 49.9288%;"><strong>Methode</strong></td>
<td style="width: 49.9288%;"><strong>Funktion</strong></td>
</tr>
<tr>
<td style="width: 49.9288%;">entrySet</td>
<td style="width: 49.9288%;">Liefert ein Set von Map.Entry-Objekten, die Key (Schlüssel) und Value (Wert) eines Eintrags enthalten</td>
</tr>
<tr>
<td style="width: 49.9288%;">keySet</td>
<td style="width: 49.9288%;">Liefert eine Collection aller Schlüssel</td>
</tr>
<tr>
<td style="width: 49.9288%;">values</td>
<td style="width: 49.9288%;">Liefert eine Collection aller Werte</td>
</tr>
</tbody>
</table>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Genereische Java Methoden und beschränkte Typen</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/java-genereische-methoden-und-beschraenkte-typen.html"/>
        <id>https://www.finecloud.ch/java-genereische-methoden-und-beschraenkte-typen.html</id>
            <category term="softwareentwicklung"/>
            <category term="parameterlisten"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="collectionlist"/>
            <category term="collection"/>

        <updated>2022-05-28T20:17:55+02:00</updated>
            <summary>
                <![CDATA[
                    Eine Methode kann einen typisierten Parameter erzwingen und einen typisierten Wert zurückgeben: public List&lt;Integer&gt; parseAlleInts(List&lt;String&gt; strings){ List&lt;Integer&gt; ergebnis = new ArrayList&lt;&gt;(); for (String s : strings){ ergebnis.add(Integer.parseInt(s)); } return ergebnis; } So ist es möglich eine Liste von Strings als Paramter in eine Liste von&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Eine Methode kann einen typisierten Parameter erzwingen und einen typisierten Wert zurückgeben:</p>
<p><code>public List&lt;Integer&gt; parseAlleInts(List&lt;String&gt; strings){        </code><br><code>    List&lt;Integer&gt; ergebnis = new ArrayList&lt;&gt;();</code><br><code>    for (String s : strings){</code><br><code>        ergebnis.add(Integer.parseInt(s));</code><br><code>    }</code><br><code>    return ergebnis;</code><br><code>}</code></p>
<p>So ist es möglich eine Liste von Strings als Paramter in eine Liste von Zahlen (Integern) umzuwandeln.</p>
            ]]>
        </content>
    </entry>
</feed>
