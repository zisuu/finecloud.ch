<!DOCTYPE html><html lang="de-ch"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM und JDK unter der Haube - Finecloud</title><meta name="description" content="Woher lädt Java eigentlich seine JDK Klassen? Beim Start einer Applikation kann mit -cp ein Klassenpfad angegeben werden, in welchem sich Klassen befinden, die man verwenden möchte. Das ist das normale Vorgehen, wie man Klassen integriert. Doch woher hat das JDK seine eigenen Klassen? Um&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://www.finecloud.ch/jvm-und-jdk-unter-der-haube.html"><link rel="alternate" type="application/atom+xml" href="https://www.finecloud.ch/feed.xml"><link rel="alternate" type="application/json" href="https://www.finecloud.ch/feed.json"><meta property="og:title" content="JVM und JDK unter der Haube"><meta property="og:site_name" content="Finecloud"><meta property="og:description" content="Woher lädt Java eigentlich seine JDK Klassen? Beim Start einer Applikation kann mit -cp ein Klassenpfad angegeben werden, in welchem sich Klassen befinden, die man verwenden möchte. Das ist das normale Vorgehen, wie man Klassen integriert. Doch woher hat das JDK seine eigenen Klassen? Um&hellip;"><meta property="og:url" content="https://www.finecloud.ch/jvm-und-jdk-unter-der-haube.html"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://www.finecloud.ch/media/website/finecloud.png" type="image/png"><link rel="stylesheet" href="https://www.finecloud.ch/assets/css/style.css?v=39da73365516a098a9b73b721fc970e2"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.finecloud.ch/jvm-und-jdk-unter-der-haube.html"},"headline":"JVM und JDK unter der Haube","datePublished":"2022-07-07T08:17","dateModified":"2022-07-07T09:04","description":"Woher lädt Java eigentlich seine JDK Klassen? Beim Start einer Applikation kann mit -cp ein Klassenpfad angegeben werden, in welchem sich Klassen befinden, die man verwenden möchte. Das ist das normale Vorgehen, wie man Klassen integriert. Doch woher hat das JDK seine eigenen Klassen? Um&hellip;","author":{"@type":"Person","name":"Finecloud","url":"https://www.finecloud.ch/authors/finecloud/"},"publisher":{"@type":"Organization","name":"Finecloud"}}</script><meta name="google-site-verification" content="seFY9U12uiEq5U3_MyZiX6XWzk0AVFl9zITr2ZKsytY"></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://www.finecloud.ch/">Finecloud</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://www.finecloud.ch/" target="_self">Blog</a></li><li><a href="https://www.finecloud.ch/tags/" target="_self">Tags</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><form action="https://www.finecloud.ch/search.html" class="search__form"><input class="search__input js-search-input" type="search" name="q" placeholder="search..." aria-label="search..." autofocus="autofocus"></form><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://www.finecloud.ch/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://www.finecloud.ch/media/website/download.jpg" srcset="https://www.finecloud.ch/media/website/responsive/download-xs.jpg 300w, https://www.finecloud.ch/media/website/responsive/download-sm.jpg 480w, https://www.finecloud.ch/media/website/responsive/download-md.jpg 768w, https://www.finecloud.ch/media/website/responsive/download-lg.jpg 1024w, https://www.finecloud.ch/media/website/responsive/download-xl.jpg 1360w, https://www.finecloud.ch/media/website/responsive/download-2xl.jpg 1600w" sizes="100vw" loading="eager" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2022-07-07T08:17">Juli 7, 2022</time></div><h1>JVM und JDK unter der Haube</h1></div></header></div><div class="wrapper post__entry"><div class="post__toc"><h3>Table of Contents</h3><ul><li><a href="#mcetoc_1g7bnagbudlj">Woher lädt Java eigentlich seine JDK Klassen?</a></li><li><a href="#mcetoc_1g7bnagbudlk">Kann man durch eine eigene java.lang.Integer Klasse die Integer JDK Klasse ersetzen?</a></li><li><a href="#mcetoc_1g7bnagbudll">Garbage Collection</a></li><li><a href="#mcetoc_1g7bnagbudlm">Speicherlecks</a></li><li><a href="#mcetoc_1g7bnagbudln">Weiche und schwache Referenzen</a></li></ul></div><h2 id="mcetoc_1g7bnagbudlj">Woher lädt Java eigentlich seine JDK Klassen?</h2><p>Beim Start einer Applikation kann mit -cp ein Klassenpfad angegeben werden, in welchem sich Klassen befinden, die man verwenden möchte. Das ist das normale Vorgehen, wie man Klassen integriert. Doch woher hat das JDK seine eigenen Klassen?</p><p>Um das zu verstehen müssen wir uns zuerst mit dem Classloader befassen. Classloader sind selbst Java-Objekte mit denen man interagieren kann. Es gibt grundsätzlich mindestens drei Classloader:</p><figure class="post__image"><img loading="lazy" src="https://www.finecloud.ch/media/posts/46/classloader.png" alt="" width="311" height="391" sizes="100vw" srcset="https://www.finecloud.ch/media/posts/46/responsive/classloader-xs.png 300w, https://www.finecloud.ch/media/posts/46/responsive/classloader-sm.png 480w, https://www.finecloud.ch/media/posts/46/responsive/classloader-md.png 768w, https://www.finecloud.ch/media/posts/46/responsive/classloader-lg.png 1024w, https://www.finecloud.ch/media/posts/46/responsive/classloader-xl.png 1360w, https://www.finecloud.ch/media/posts/46/responsive/classloader-2xl.png 1600w"></figure><ul><li><em>Bootstrap-Classloader</em>: lädt die JDK-Klassen</li><li><em>Extension-Classloader</em>: lädt Klassen, die in Javas Erweiterungsverzeichnis liegen. In diesem selten genutzten Verzeichnis können Erweiterungen des JDKs abgelegt werden, die jeder Anwendung zur Verfügung stehen, ohne dass sie sie in den eigenen Klassenpfad aufnehmen müsste. Der Default ist das Erweiterungsverzeichnis im Java-Installationsverzeichnis unter lib/ext zu finden.</li><li><em>System-Classpath-Classloader</em>: Der Classloader der Anwendung. Er lädt die Klassen welche mit -cp im angegebenen Verzeichnis liegen.</li></ul><h2 id="mcetoc_1g7bnagbudlk">Kann man durch eine eigene java.lang.Integer Klasse die Integer JDK Klasse ersetzen?</h2><p>Diese drei Klassloader stehen in einer hierarchischen Beziehung miteinander. Wenn man nun in seiner Applikation Klassen lädt, geschieht das immer mit dem System-Classpath-Classloader. Im ersten Schritt fragt jeder Classloader bei seinem übergeordneten Classsloader nach, ob dieser die Klasse laden kann. Diese Reihenfolge ist extrem wichtig, denn sie privilegiert die JDK Klassen. Eine Klasse, die dem Bootstrap-Classloader bekannt ist, kann deshalb niemals durch eine andere Klasse desselben Namens verdrängt werden. Etwas komplizierter ist das bei den Serverlet-Container.</p><h2 id="mcetoc_1g7bnagbudll">Garbage Collection</h2><p>Jedes erzeugte Java-Objekt belegt Speicher und der JVM steht nur eine begrenzte Speichermenge zur Verfügung. Es muss also eine Möglichkeit geben, Objekte wieder aus dem Speicher zu entfernen, wenn diese nicht mehr benötigt werden. Ansonsten wird jede Java-Anwendung irgendwann mit einem <em>OutOfMemoryError</em> beendet. Dieser Mechanismus nennt sich Garbage Collection.</p><p>Andere systemnähere Programmiersprachen haben keinen solchen Mechanismus und überlassen diese Aufgabe dem Entwickler selbst. Viele moderne Sprachen bieten mittlerweile eine automatische Garbage Collection an, aber Java war eine der ersten mit diesem Feature.</p><p>Welche Objekte nicht mehr verwendet werden, findet der Garbage Collector heraus, indem er Referenzen untersucht. Dazu geht er von den Garbage Collection Roots aus und folgt allen Referenzen von diesen Objekten aus. Alle Objekte, die von einer Root referenziert werden, werden als noch aktiv markiert. Objekte, die von diesen Objekten aus referenziert werden, werden ebenfalls markiert usw. Garbage Collection Roots können Class-Objekte, lebende Threads, Lokale Variablen und Parameter, Monitor-Objekte, JNI-Variablen und spezielle JVM-Objekte sein. Rekursiv werden so alle Objekte markiert, die von einer Garbage Collection Root direkt oder indirekt erreichbar sind. Anschliessend werden alle Objekte die nicht von einer Root aus erreichbar sind aus dem Speichern entfernt. Dieses Vorgehen nennt sich <em>Mark and Sweep Collection</em>. Die echten Abläufe der Garbage Collection sind noch etwas komplexer als hier beschrieben.</p><h2 id="mcetoc_1g7bnagbudlm">Speicherlecks</h2><p>Speicherlecks in Java kommen fast immer daher, dass man Objekte mit einer der Garbage Collection Roots verbinden und nicht wieder von dort entfernen. Am häufigsten passiert das mit statischen Variablen. Es ist leicht zu vergessen, dass ihr Inhalt nicht von selbst aus dem Speicher entfernt wird, im Unterschied zu Instanzvariablen. So kann man unbeabsichtigt viel Speicher belegen, indem man ein grosses Objekt in einer statischen Variablen hält, obwohl es bereits nicht mehr benötigt wird. Dabei handelt es sich aber nicht um ein Speicherleck, denn der belegte Speicher bleibt konstant und wächst mit der Zeit nicht mehr an. Ein echtes Speicherleck kann dadurch entstehen, dass man eine Collection in einem statischen Feld hält, der immer weiter Objekte hinzugefügt werden:</p><pre class="hljs" style="color: #a9b7c6; background: #282b2e none repeat scroll 0% 0%; display: block; overflow-x: auto; padding: 0.5em;"><span class="hljs-function"><span class="hljs-keyword" style="color: #cc7832;">public</span> class <span class="hljs-title" style="color: #ffc66d;">Speicherleck</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword" style="color: #cc7832;">private</span> <span class="hljs-keyword" style="color: #cc7832;">static</span> <span class="hljs-keyword" style="color: #cc7832;">final</span> Map&lt;String, Speicherleck&gt; cache = <span class="hljs-keyword" style="color: #cc7832;">new</span> HashMap&lt;&gt;();
    <span class="hljs-keyword" style="color: #cc7832;">private</span> String name;

    <span class="hljs-function"><span class="hljs-keyword" style="color: #cc7832;">public</span> <span class="hljs-title" style="color: #ffc66d;">Speicherleck</span><span class="hljs-params">(String name)</span></span>{
        <span class="hljs-keyword" style="color: #cc7832;">this</span>.name = name;
        cache.put(name, <span class="hljs-keyword" style="color: #cc7832;">this</span>);
    }
}</pre><p>Jede Instanz der Klasse Speicherleck, die jemals erzeugt wird, wird in der statischen map cache gespeichert, aber nie wieder von dort entfernt. Das führt dazu, dass keine Instanz von Speicherleck jemals vom Garbage Collector entsorg werden kann, denn alle Instanzen werden von einem statischen Feld referenziert. Es kann natürlich sein, dass Sie diese Objekte wirklich noch brauchen, aber häufiger handelt es sich bei solchen Konstrukten um einen Fehler.</p><p>Weitere Quellen für Speicherlecks in Java sind ThreadLocals, Variablen, die direkt mit einem Thread verbunden sind. Die genauen Mechanismen, wie es zu einem Speicherleck kommen kann, sind sehr ähnlich wie bei statischen Feldern: Solange der Thread lebendig ist, kann der Inhalt eines ThreadLocal nicht aus dem Speicher entfernt werden. Eine wachsende Collection dort hat deshalb denselben zerstörerischen Effekt wie in einem Statischen Feld.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on Juli 7, 2022</p><ul class="post__tag"><li><a href="https://www.finecloud.ch/tags/classloader/">classloader</a></li><li><a href="https://www.finecloud.ch/tags/dev/">dev</a></li><li><a href="https://www.finecloud.ch/tags/java/">java</a></li><li><a href="https://www.finecloud.ch/tags/softwareentwicklung/">software development</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://www.finecloud.ch/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://www.finecloud.ch/guis-mit-javafx.html" class="post__nav-link" rel="prev"><span>Previous</span> GUIs mit JavaFX</a></div><div class="post__nav-next"><a href="https://www.finecloud.ch/citrix-adc-backup-mit-ansible.html" class="post__nav-link" rel="next"><span>Next</span> Citrix ADC (NetScaler) Backup mit Ansible </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://www.finecloud.ch/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav><div class="post__related related"><div class="wrapper"><h2 class="h5 related__title">You should also read:</h2><article class="related__item"><div class="feed__meta"><time datetime="2022-07-08T16:43" class="feed__date">Juli 8, 2022</time></div><h3 class="h1"><a href="https://www.finecloud.ch/unterschiede-zwischen-proxmox-containers-und-docker.html">Unterschiede zwischen Proxmox Containers und Docker</a></h3></article><article class="related__item"><div class="feed__meta"><time datetime="2022-06-04T15:42" class="feed__date">Juni 4, 2022</time></div><h3 class="h1"><a href="https://www.finecloud.ch/dateien-und-verzeichnisse-unter-java.html">Dateien und Verzeichnisse unter Java</a></h3></article></div></div></main><footer class="footer"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="https://www.finecloud.ch/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://www.finecloud.ch/assets/js/scripts.min.js?v=6ca8b60e6534a3888de1205e82df8528"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>