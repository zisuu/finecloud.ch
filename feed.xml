<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Finecloud</title>
    <link href="https://www.finecloud.ch/feed.xml" rel="self" />
    <link href="https://www.finecloud.ch" />
    <updated>2022-05-31T12:06:01+02:00</updated>
    <author>
        <name>Finecloud</name>
    </author>
    <id>https://www.finecloud.ch</id>

    <entry>
        <title>Parallele Streams</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/parallele-streams.html"/>
        <id>https://www.finecloud.ch/parallele-streams.html</id>
            <category term="threads"/>
            <category term="stream-api"/>
            <category term="softwareentwicklung"/>
            <category term="parallel"/>
            <category term="lambda"/>
            <category term="java"/>
            <category term="dev"/>

        <updated>2022-05-31T12:06:01+02:00</updated>
            <summary>
                <![CDATA[
                    Streams können die Arbeit an Listen von Daten erheblich vereinfachen. Sie haben die Fähigkeit, die vor allem bei grossen Datenmengen extrem nützlich sein kann: Sie können in mehren Threads arbeiten. Das kann die Datenverarbeitung erheblich beschleunigen. Sie müssen dazu nicht selbst neue Threads starten, Streams&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Streams können die Arbeit an Listen von Daten erheblich vereinfachen. Sie haben die Fähigkeit, die vor allem bei grossen Datenmengen extrem nützlich sein kann: Sie können in mehren Threads arbeiten. Das kann die Datenverarbeitung erheblich beschleunigen.</p>
<p>Sie müssen dazu nicht selbst neue Threads starten, Streams erledigen das für Sie. Manchmal können Sie einen Stream gleich als einen parallelen Stream erzeugen, zum Beispiel, indem Sie an einer Collection parallelStream anstelle von stream aufrufen. Es ist aber auch möglich einen Stream nachträglich in einen parallelen Stream umzuwandeln, indem die Methode parallel gerufen wird, oder wieder in einen sequenziellen Stream, also einen Stream, der in nur einem Thread verarbeitet wird, mit der Methode sequential. Beide Methoden sind intermediär, dadurch können Sie sogar in einer Pipeline einige Schritte parallel und andere sequenziell ausführen:</p>
<p><code>studentenDatei</code><br><code>        .lines()</code><br><code>        .parallel()</code><br><code>        .map(line -&gt; parseStudent(line))</code><br><code>        .filter(student -&gt; student.getNotendurchschnitt() &gt;= 5.0)</code><br><code>        .sequential()</code><br><code>        .forEach(student -&gt; schreibeInDatei(student)); </code></p>
<p>Im Beispiel wird eine Datei mit Studentendaten eingelesen, darin werden alle Studenten mit einem Notendurchschnitt von 5.0 oder höher in eine neue Datei geschrieben. Dazu werden zunächst die aus der Datei gelesenen Strings in Student-Objekte gemappt und nach Notendurchschnitt gefiltert. Diese Operationen können parallel ausgeführt werden, ohne dass es zu Fehlern kommt. In die Ausgabedatei muss aber ein Datensatz nach dem anderen geschrieben werden, es können nicht mehrere Threads gleichzeitig in dieselbe Datei schreiben. Dazu wird von dem terminalen <em>forEach</em> der Stream wieder sequenziell gemacht. So sind die Aufgaben, die in mehreren Threads verarbeitet werden können, parallel, aber die, bei denen es nicht geht, sequenziell.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Die Stream-API</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/die-stream-api.html"/>
        <id>https://www.finecloud.ch/die-stream-api.html</id>
            <category term="stream-api"/>
            <category term="softwareentwicklung"/>
            <category term="lambda"/>
            <category term="java"/>
            <category term="dev"/>

        <updated>2022-05-31T11:55:10+02:00</updated>
            <summary>
                <![CDATA[
                    Das konsequente Fluent Interface der Stream-API macht es möglich, mit einem Blick zu erkennen was durch einen Lambda-Ausdruck in jeder einzelnen Zeile geschieht. Mit diesem Beispiel werden alle Vielfachen von 3 zwischen 0 und 100 ausgegeben: IntStream.range(0, 100) .filter(i -&gt; i % 3 == 0)&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Das konsequente Fluent Interface der Stream-API macht es möglich, mit einem Blick zu erkennen was durch einen Lambda-Ausdruck in jeder einzelnen Zeile geschieht. Mit diesem Beispiel werden alle Vielfachen von 3 zwischen 0 und 100 ausgegeben:</p>
<p><code>IntStream.range(0, 100)</code><br><code>        .filter(i -&gt; i % 3 == 0)</code><br><code>        .forEach(System.out::println);</code></p>
<p>Richtig praktisch werden solche Lambda und Streams beim lesen von Dateiinhalten:</p>
<p><code>BufferedReader danksagung = new BufferedReader(new FileReader("ebook.txt"))</code><br><code>danksagung.lines()</code><br><code>        .filter(line -&gt; line.toLowerCase().contains("Danksagung"))</code><br><code>        .findFirst()</code><br><code>        .ifPresent(System.out::println);</code></p>
<p>Ab welcher Zeile startet im E-Book die Danksagung? Mit findFrist wird nur die erste Zeile gesucht, in der ein Ergebnis steht, anschliessend wird nicht mehr weiter gesucht, sondern das Ergebnis wird ausgegeben.</p>
<p>Streams sind eine andere Art in Java mit Listen von Daten umzugehen, aber sie sind keinen Ersatz für Collections oder Arrays, eher eine Ergänzung. Streams fehlt nämlich eine Eigenschaft, welche den anderen Datenstrukturen haben: Permanenz. In einer Collection speichern Sie Daten, um bei Bedarf wieder darauf zuzugreifen und zwar so oft sie wollen. Ein Stream dient lediglich der Verarbeitung von Daten. Sie können den Inhalt einen Streams genau einmal auslesen, danach ist er weg und nicht mehr zurückzubekommen. Insofern gleicht ein Stream eher einem Iterator als einer Collection. Wenn Sie auf die Ausgabe der Pipeline nach Belieben wieder zugreifen möchten, dann müssen Sie sie wieder in einer Collection sammeln.</p>
<h3>Intermediäre und terminale Methoden</h3>
<p>Der Unterschied ist, das Intermediäre Methoden wieder ein Stream zurückgeben mit dem man weiterarbeiten kann, terminale Methoden geben einen anderen Ergebnistyp zurück. So entsteht eine Pipeline, die durch die terminale Methode gesteuert wird. Sie "zieht" Daten aus dem Stream und erst durch die terminale Methode werden überhaupt Daten aus dem Stream gelesen. Solange Sie nur intermediäre Methoden aufrufen, passiert im Stream noch nichts.</p>
<p><em>findFrist</em> gibt keinen Stream mehr zurück, sondern ein Optional und if-Present ist eine Methode davon. <em>findFirst</em> ist eine terminale Methode, also eine die am Ende der Stream-Verarbeitung steht. <em>filter</em> dagegen ist eine intermediäre Methode und steht in der Mitte der "Pipeline".</p>
<p>Schauen wir uns das mit dem Beispiel von oben an:</p>
<ul>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Die Methode BufferedReader.lines erzeugt einen Stream&lt;String&gt;. Es werden noch keine Daten gelesen.</span></li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Aus diesem Stream wird mit filter ein neuer Stream erzeugt, der die Filteranweisung verarbeitet. Es werden noch immer keine Daten gelesen.</span></li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Die terminale Methode findFirst wird gerufen. Nun beginnt die Verarbeitung.</span></li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">findFirst liest das erste Element aus dem gefilterten Stream.</span></li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Der gefilterte Stream liest das erste Element des ungefilterten Streams und wertet sein Prädikat line.toLowerCase().contains("Danksagung") aus.</span></li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Die erste Zeile "Einleitung" wird vom Filter zurückgewiesen. Der gefilterte Stream liest die zweite Zeile des ungefilterten Streams und wendet erneut sein Prädikat an. Auch diese Zeile wird zurückgewiesen.</span></li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Erst Zeile Nummer X wird vom Filter akzeptiert. Jetzt gibt der gefilterte Stream seine erste Rückgabe: "Danksagung".</span></li>
<li>findFirst empfängt die Rückgabe vom gefilterten Stream. Es benötigt keine weiteren Ergebnisse. Es wird nur der erste Treffer gesucht, deshalb wird kein weiteres Element aus dem gefilterten Stream gelesen.</li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">findFirst schliesst den gefilterten Stream und gibt das gefundene Ergebnis (richtiger: ein Optional mit dem gefundenen Ergebnis) zurück.</span></li>
<li><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Was ist wirklich passiert? Es wurden 13 Zeilen aus dem ungefilterten Stream gelesen, davon wurde eine Zeile in den gefilterten Stream weitergeschrieben. Mehr nicht.</span></li>
</ul>
<p>Damit wurde keine Zeile mehr gelesen, als notwendig. Streams sind nicht nur gut darin, Ihre Absichten in Code auszudrücken, sie sind dabei auch noch äusserst effizient.</p>
<h3>Intermediäre Operatoren</h3>
<h5><strong>Sortieren (sort)</strong></h5>
<p>Einen Stream kann nach seiner natürlichen Ordnung sortiert werden, wenn seine Elemente Comparable implementieren, oder mit einem übergebenen Comparator. In allen Fällen bleibt der Inhalt der Datenquelle unverändert. Nachfolgend ein Beispiel, darin wird der heisseste Tag im Jahr gesucht, zuerst wird absteigend nach Temperatur sortiert und dann das erste Element selektiert:</p>
<p><code>tagestemperaturen</code><br><code>        .sorted(Comparator</code><br><code>                .comparing(Tagestemperatur::getTemperatur)</code><br><code>                .reversed())</code><br><code>        .findFirst();</code></p>
<h5>Limitieren (limit)</h5>
<p>Meistens will man nur auf einem teil des Streams arbeiten, z.B. nur auf dem Anfang. Mit limit kann ein Stream auf eine beliebige Anzahl von Elementen beschränkt werden. Auch wenn der darunterliegende Stream mehr Elemente hätte, endet der limitierte Stream, wenn seine Anzahl erreicht ist. Im Beispiel werden die zehn besten Songs aus einer Sammlung sortiert, limitiert und ausgegeben:</p>
<p><code>songs</code><br><code>        .sorted(Comparator.comparing(Song::getSterne).reversed())</code><br><code>        .limit(10)</code><br><code>        .forEach(song -&gt; System.out.println(song.getTitel()));</code></p>
<h5>Überspringen (skip)</h5>
<p>Will man nicht nach einem bestimmen Inhalt suchen, sondern diesen bestimmten Inhalt bewusst überspringen. Folgende Datei soll eingelesen werden:</p>
<p><em>Höchsttemperaturen Basel</em><br><em>Datum;Temperatur</em><br><em>01.3.2021;1</em><br><em>02.3.2021;3</em><br><em>13.3.2021;8</em><br><em>…</em></p>
<p>dabei interessieren uns aber nur die Temperaturen, die ersten zwei Zeilen interessieren uns nicht:</p>
<p><code>daten.lines()</code><br><code>        .skip(2)</code><br><code>        .map(TemperaturMessung::parse)</code><br><code>        ...</code></p>
<h5>Filtern (filter)</h5>
<p>Man übergibt ihr ein Predicate und nur die Elemente, für die das Predicate true liefert, werden im Stream weitergereicht:</p>
<p><code>kandidaten</code><br><code>        .filter(k -&gt; k.getHaarfarbe().equals("rot") </code><br><code>                &amp;&amp; k.getAugenfarbe().equals("grün"))</code><br><code>        .forEach(k -&gt; sprichAn(k));</code></p>
<h5>Einmaligkeit (distinct)</h5>
<p>Wenn in einem Stream Duplikate entfernt werden sollen, kann das mit distinct sichergestellt werden. Damit merkt sich der Strom alle Elemente, die bereits einmal vorkamen und gibt sie kein zweites Mal zurück. Bei Streams von Objekten wird Gleichheit mit equals bestimmt. Achtung: distinct ist eine Operation mit Zustand und kann für lange Streams sehr viel Speicher belegen.</p>
<p><code>kontakte</code><br><code>        .distinct()</code><br><code>        .count();</code></p>
<h5>Abbilden</h5>
<p>Das sind alle Operationen, die aus den Eingabewerten etwas berechnen und als Ausgabestrom wieder ausgeben:</p>
<p><code>personen</code><br><code>        .map(Person::getName)</code><br><code>        .forEach(System.out::println);</code></p>
<p>Mit der map-Methode ist der Ausgabe-Stream wieder ein Stream von Objekten; wenn das Ergebnis der Function ein primitiver Typ ist, wird er dazu in den passenden Wrapper konvertiert. Wenn man deinen Stream von primitiven Typen als Ausgaben benötigt, stehen dafür die Methoden <em>mapToInt</em>, <em>mapToLong</em> und <em>mapToDouble</em> zur Verfügung.</p>
<p>Etwas komplizierter ist die Methode flatMap und ihre primitiven Gegenstücke. Sie erwarten als Parameter eine Funktion, die aus jedem Eingabeelement einen Stream erzeugt. Die Ausgabe von flatMap ist ein Stream, in dem die Elemente aller Streams jeweils nacheinander zu einem Ausgabe Stream zusammengefasst sind. Als Beispiel: Das Stadtfest in Ihrer Stadt. Es war eine Anmeldung erforderlich und von jeder Anmeldung wird erwartet, dass die gesamte Familie mitkommt. Anmeldungen sind in einem Objekt vom typ Person gespeichert, das den Namen der Person enthält, seinen oder ihren Partner als weiteres Person-Objekt und die Kinder als Liste von Personen. Angemeldet sind:</p>
<ul>
<li>Hans Fischer mit Partner Frieda Fischer und den Kindern Fritz, Max und Lisa</li>
<li>Ida mit Partner Martin</li>
<li>Max Müller mit seinen Kindern Moritz und Peter</li>
</ul>
<p>Von der ersten Anmeldung ausgehend soll nun eine Liste aller erwarteten Gäste ausgegeben werden:</p>
<p><code>anmeldungen</code><br><code>        .flatMap(p -&gt; Stream.concat(</code><br><code>                Stream.of(p, p.getPartner()), </code><br><code>                p.getKinder().stream()))</code><br><code>        .filter(p -&gt; p != null)</code><br><code>        .map(Person::getName)</code><br><code>        .forEach(System.out::println);</code></p>
<p>Mit flatMap ist die Liste schnell erstellt, aber was genau passiert, ist auch mit Lambda-Ausdrücken nicht sofort ersichtlich:</p>
<ul>
<li>Mit Stream.of wird ein Stream erzeugt, der die person selbst und ihren Partner enthält. Dank Varargs können Stream.of einfach alle Elemente übergeben werden, die der so erzeugt Stream enthalten soll.</li>
<li>Aus der Liste von Kindern wird ein weiterer Stream erzeugt. Da die Kinder in einer Collection gespeichert sind, kann da smit der stream-Methode erreicht werden.</li>
<li>Diese beiden Stream werden mit Stream.concat zusammengesetzt. Die Methode gibt einen Stream zurück, der das Erste aller Elemente des ersten übergebenen Streams und danach allen Elemente des zweiten übergebenen Streams enthält.</li>
<li>flatMap wird für jede Person aus <em>anmeldungen</em> gerufen, intern werden dadurch drei Stream erzeugt: [Hans Fischer, Frieda Fischer, Fritz, Max, Lisa][Ida, Martin][Max Müller, null, Moritz und Peter]. Da Max Müller keinen Partner (mehr) hat, resultiert aus p.getPartner() ein null-Wert; dieser wird von der späteren filter-Anweisung wieder entfernt werden.</li>
<li>flatMap gibt aber nicht einen Stream pro Eingabe zurück (das käme bei map heraus), sondern nur einen langen Stream. Daher auch der Name flatMap: Anstatt einen Stream von Streams auszugeben, ist die Ausgabe flach. Der so erzeugte Stream enthält also: [Hans Fischer, Frieda Fischer, Fritz, Max, Lisa, Ida, Martin, Max Müller, null, Moritz und Peter]</li>
</ul>
<h5>Spicken (peek)</h5>
<p>peek gibt genau denselben Stream aus, der auch eingegeben wurde, führt aber für jedes Element einen Consumer aus. Der Inhalt des Streams wird nicht verändert. Mit peek können Sie einem Stream bei der Arbeit zuschauen, was insbesondere bei Fehlersuche hilfreich ist:</p>
<p><code>danksagung.lines()</code><br><code>        .peek(line -&gt; System.out.println("Ungefiltert " + line))</code><br><code>        .filter(line -&gt; line.toLowerCase().contains("Danksagung"))</code><br><code>        .peek(line -&gt; System.out.println("Gefiltert " + line))</code><br><code>        .findFirst()</code><br><code>        .ifPresent(System.out::println);</code></p>
<p>peek kann auch verwendet werden, um beispielsweise bei Anmeldungen Bestätigungen zu versenden:</p>
<p><code>anmeldungen</code><br><code>        .peek(p -&gt; bestaetigeAnmeldung(p))</code><br><code>        .flatMap(p -&gt; Stream.concat(Stream.of(</code><br><code>                p, p.getPartner()), </code><br><code>                p.getKinder().stream()))</code><br><code>        .filter(p -&gt; p!= null)</code><br><code>        .map(Person::getName)</code><br><code>        .forEach(System.out::println);</code></p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Lambda Funktionale Interfaces</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/lambda-funktionale-interfaces.html"/>
        <id>https://www.finecloud.ch/lambda-funktionale-interfaces.html</id>
            <category term="softwareentwicklung"/>
            <category term="lambda"/>
            <category term="java"/>
            <category term="interface"/>
            <category term="functional"/>
            <category term="dev"/>

        <updated>2022-05-30T16:46:59+02:00</updated>
            <summary>
                <![CDATA[
                    Lambda Interfaces sind häufig benötigte Lambda-Ausdrücke, die Teil des JDKs sind und damit nicht in jedem Projekt wieder neu angelegt werden müssen. Zum Beispiel kann mit dieser Methode eine Summe aus Objekten berechnet werden: public static &lt;T&gt; long summiere(List&lt;T&gt; tees, ToIntFunction&lt;T&gt; func){ long result =&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Lambda Interfaces sind häufig benötigte Lambda-Ausdrücke, die Teil des JDKs sind und damit nicht in jedem Projekt wieder neu angelegt werden müssen.</p>
<p>Zum Beispiel kann mit dieser Methode eine Summe aus Objekten berechnet werden:</p>
<p><code>public static &lt;T&gt; long summiere(List&lt;T&gt; tees, ToIntFunction&lt;T&gt; func){</code><br><code>    long result = 0;</code><br><code>    for (T tee : tees){</code><br><code>        result += func.applyAsInt(tee);</code><br><code>    }</code><br><code>    return result;</code><br><code>}</code></p>
<p>Alle Interfaces die Lambda-Ausdrücke ermöglichen, sind Bestandteil des Packages java.util.function. Darin sind rund 40 Interfaces enthalten. Eine konsequente Namenskonvention hilft den Überblick zu behalten. Dabei werden die Interfaces grundlegend nach der Form benannt, also nach Parametern und Rückgabewerten. Diese grundlegenden Interfaces arbeiten mit Objekten. Für Interfaces, die dieselbe Operation für Primitive bereitstellen, wird der Name des primitiven Typs vorangestellt:</p>
<ul>
<li>Function&lt;T, R&gt; erwartet ein Objekt vom Typ T als Parameter und gibt ein Objekt vom Typ R zurück.</li>
<li>ToIntFunction&lt;T&gt; erwartet ein Objekt vom Typ T als Parameter und gibt einen int-Wert zurück.</li>
<li>DoubleToIntFunction erwartet einen double-Wert als Parameter und gibt einen int-Wert zurück.</li>
</ul>
<p>Nicht alle möglichen Kombinationen stehen zur Verfügung, aber die am häufigsten gebrauchten sind da. Nachfolgend schauen wir uns die grundlegenden Formen von funktionalen Interfaces an.</p>
<h3>Function</h3>
<p>Funktionsobjekte entsprechen in etwa der mathematischen Definition von einstelligen Funktionen: Sie bilden einen Wert auf einen anderen ab. Eine einfache Function ist eine Abbildung von einem Objekt auf ein anderes Objekt, eine ToIntFunction eine Abbildung von einem Objekt auf einen int-Wert usw.</p>
<p>Im vorherigen Codebeispiel haben wir eine Anwendung für ToIntFuntion gesehen, dort werden Objekte auf einen Int-Wert abgebildet, der anschliessend zu einer laufenden Summe addiert wird. Auch die Methode Comparator.comparing erwartet ein Function-Objekt als Parameter:</p>
<p><code>Comparator&lt;Song&gt; nachTitel = Comparator.comparing(s -&gt; s. getTitel());</code></p>
<p>In diesem Beispiel werden Songs nach ihrem Titel sortiert, indem jeder Song als einen String, sein Titel abbildet und anschliessend nach der natürlichen Reihenfolge dieser Strings sortiert wird. Genau in diesem Fall können Sie auch eine Methodenreferenz verwenden: (da der Lambda-Ausdruck lediglich aus einem parameterlosen Methodenaufruf besteht):</p>
<p><code>Comparator&lt;Song&gt; nachTitel = Comparator.comparing(Song::getTitel);</code></p>
<p>Es gibt aber auch Funktionen deren Eingabe- und Ausgabetypen identisch sind, diese werden als Unary-Operator bezeichnet. So gibt es zum Beispiel den IntUnaryOperator, der einen int-Wert auf einen anderen int-Wert abbildet.</p>
<h3>Predicate</h3>
<p>Funktionen bei denen der Eingabewert immer auf eine boolean-Ausgabe abgebildet wird, werden Prädikate genannt. Predicate könnte also auch ToBooleanFunction heisst, hat aber wegen seiner besonderen Bedeutung einen eigenen Namen erhalten. Predicate sind besonders wichtig zum Filtern. Damit kann ein Stream mit einem Predicate-Objekt gefiltert werden, so dass nur noch die Elemente enthalten sind, die das Prädikat erfüllen, für die der Lambda-Ausdruck also true zurückgibt:</p>
<p><code>List&lt;Song&gt; songs = …;</code><br><code>songs.stream().filter(s -&gt; s. getSterne() == 5).count();</code></p>
<p>Doch damit nicht genug, es ist weiter möglich Predicate mit logischen Operatoren AND, OR und NOT anzuwenden und somit mehrere Predicate zu einem einzigen zu verknüpfen:</p>
<p><code>private static Predicate&lt;Song&gt; baueSuchPredicate(String suchtitel,</code><br><code> String suchinterpret, int suchsterne) {</code><br><code>    Predicate&lt;Song&gt; filter = (s-&gt;true);</code><br><code>    if (suchtitel != null){</code><br><code>        filter = filter.and(s -&gt; </code><br><code>                s.getTitel().startsWith(suchtitel));</code><br><code>    }</code><br><code>    if (suchinterpret != null){</code><br><code>        filter = filter.and(s -&gt; </code><br><code>                s.getInterpret().startsWith(suchinterpret));</code><br><code>    }</code></p>
<p><code></code><code> if (suchsterne &gt; 0){</code><br><code>        filter = filter.and(s -&gt; s. getSterne() &gt;= suchsterne);</code><br><code>    }</code><br><code>    return filter;</code><br><code>}</code></p>
<p>Die Initialisierung mit Predicate&lt;Song&gt; filter = (s-&gt;true) wird deshalb so vorgenommen, damit es ein erstes Objekt gibt, an dem Sie überhaupt and rufen können. Anderenfalls müssten Sie bei jedem Suchattribut wieder prüfen, ob es schon einen Filter gibt, falls ja, and rufen, und falls nein, einen erzeugen.</p>
<h3>Consumer</h3>
<p>Dabei handelt es sich um Funktionen ohne Rückgabewert. Sie erwarten einen Parameter, den sie verarbeiten, liefern aber kein Ergebnis:</p>
<p><code>public static void main(String[] args) throws IOException{</code><br><code>    liesStrings((s) -&gt; System.out.println(s));</code><br><code>}</code><br><code>    </code><br><code>public static void liesStrings(Consumer&lt;String&gt; sink) throws IOException{</code><br><code>    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));</code><br><code>    String line;</code><br><code>    while (!"".equals(line = in.readLine())){</code><br><code>        sink.accept(line);</code><br><code>    }</code><br><code>}</code></p>
<p>Die Methode liesStrings liest so lange beliebig viele Strings von der Standardeingabe, bis eine leere Zeile gelesen wird und gibt jede gelesene teile an den übergebenen Consumer&lt;String&gt; weiter. Im Beispiel werden die gelesenen Strings einfach wieder ausgegeben, aber dieselbe Methode könnte eine Eingabe auch in einer Liste sammeln, oder jede Zeile als Kommando interpretieren:</p>
<p><code>//Zeilen in eine Liste lesen</code><br><code>List&lt;String&gt; zeilen = new ArrayList&lt;&gt;();</code><br><code>liesStrings(zeilen::add);</code><br><code>//Zeilen als Kommandos ausführen</code><br><code>liesStrings(this::fuehreKommandoAus);</code></p>
<h3>Supplier</h3>
<p>Supplier ist das Gegenstück zum Consumer, sie haben keine Parameter, geben aber etwas zurück.</p>
<p>Welchen Sinn kann ein solcher Aufruf</p>
<p><code>zeigeNachricht(() -&gt; entschluessleNachricht(nachricht))</code><br><br>gegenüber dem folgenden, einfacheren haben?<br><br><code>zeigeNachricht(entschluessleNachricht(nachricht))</code><br><br>In diesem Beispiel können Sie unnötigen Rechenaufwand vermeiden. Die Methode zeigeNachricht stammt aus einem fiktiven E-Mail-Client, der Verschlüsselung beherrscht. Ihre Implementierung könnte so aussehen:<br><br><code>public zeigeNachricht(String nachricht){</code><br><code>    if (zeigeVorschau)</code><br><code>        System.out.println(nachricht);</code><br><code>}</code></p>
<p>Im Beispiel wird die entschlüsselte Nachricht an die Methode übergeben, obwohl noch nicht klar ist, ob sie überhaupt benötigt wird. Wenn zeigeVorschau false ist, dann wird der Parameter ignoriert und die potenziell teure Entschlüsselung war umsonst.</p>
<p><code>public zeigeNachricht(Supplier&lt;String&gt; nachricht){</code><br><code>    if (zeigeVorschau)</code><br><code>        System.out.println(nachricht.get());</code><br><code>}</code></p>
<p>Nicht so in diesem Fall. Die Nachricht wird erst dann entschlüsselt, wenn am Supplier get gerufen wird, solange get nicht gerufen wird, wird die Nachricht nicht entschlüsselt.</p>
<h3>BiFunction, BiPredicate, BiConsumer</h3>
<p>Zu diesen Funktionen gibt es jeweils noch eine Variante mit einem vorangestellten Bi-. Diese unterscheiden sich von ihren einfachen Gegenstücken dadurch, dass sie zwei Parameter statt einem nehmen. Ein BiPredicate bildet also zum Beispiel zwei Objekte auf einen boolean-Wert ab. Funktionen die zwei gleichartige Wert auf einen dritten Wert desselben Typs abbilden heissen BinaryOperator.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Lambda-Ausdrücke Teil 2</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/lambda-ausdruecke-2.html"/>
        <id>https://www.finecloud.ch/lambda-ausdruecke-2.html</id>
            <category term="softwareentwicklung"/>
            <category term="lambda"/>
            <category term="java"/>
            <category term="dev"/>

        <updated>2022-05-29T15:35:47+02:00</updated>
            <summary>
                <![CDATA[
                    Im ersten Teil zum Thema Lambda-Ausdrücke haben wir gelernt was Lambda-Ausdrücke sind und wie man diese verwenden kann. Im zweiten Teil schauen wir nun hinter die Kulissen, wie Lambda-Ausdrücke funktionieren. Zentral zum Verständnis, wie Lambda-Ausdrücke in Java funktionieren, ist der Begriff des funktionalen Interface. Das&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Im ersten Teil zum Thema Lambda-Ausdrücke haben wir gelernt was Lambda-Ausdrücke sind und wie man diese verwenden kann. Im zweiten Teil schauen wir nun hinter die Kulissen, wie Lambda-Ausdrücke funktionieren.</p>
<p>Zentral zum Verständnis, wie Lambda-Ausdrücke in Java funktionieren, ist der Begriff des <em>funktionalen Interface</em>. Das ist ein Interface, das nur eine Methode definiert. Das war bereits vor der Lambda Einführung eine übliche Möglichkeit, in Java Funktionalität als Parameter zu übergeben.</p>
<p><code>Arrays.sort(einArray, new Comparator(){</code><br><code>    public int compareTo(Object o1, Object o2){…}</code><br><code>});</code></p>
<p>Comparator ist ein funktionales Interface, es deklariert nur die Methode compareTo. Aber ein Lambda-Ausdruck kann überall dort, wo ein funktionales Interface als Parametertyp angeben wird eingesetzt werden. Das heisst auch als Comparator:</p>
<p><code>Arrays.sort(songs, (song1, song2) -&gt; </code><br><code> song1.getLaengeInSekunden() - song2.getLaengeInSekunden())</code></p>
<p>Das funktioniert mit allen funktionalen Interfaces, auch eigene. Wenn Sie ein Interface deklarieren, das nur eine Methode enthält, dann können Sie, um dieses Interface zu implementieren, auch Lambda-Ausdrücke verwenden.</p>
<h3>Closures</h3>
<p>Oft wird für Lambda-Ausdrücke auch der Begriff Closure verwendet. Die beiden gehören untrennbar zusammen, sind aber nicht dasselbe.</p>
<p>Ein Lambda-Ausdruck ist definiert als eine anonyme Funktion. Er erfüllt dieselbe Aufgabe wie eine Methode, hat aber keinen Namen.</p>
<p>Ein Closure hingegen ist ein Bündel aus einer Funktion und der Umgebung, aus der heraus diese Funktion aufgerufen wurde. Mit Umgebung sind hier die lokalen Variablen gemeint welche zum Zeitpunkt des Aufrufs im Scope liegen. Das beim Erzeugen der anonymen Objektinstanz oder der Lambda-Instanz eine Closure gebildet wird, erlaubt es, auf die Werte der lokalen Variablen auch dann noch zuzugreifen, wenn sie schon nicht mehr im Scope liegen:</p>
<p><code>public static void main(String[] args) throws Exception {</code><br><code>    IntSupplier test = erzeugeClosure();</code><br><code>    new Thread(() -&gt; System.out.println(test.getAsInt())).start();</code><br><code>}</code><br><code>public static IntSupplier erzeugeClosure() {</code><br><code>    int wert = 123;</code><br><code>    return (() -&gt; wert);</code><br><code>}</code></p>
<p>Die Funktion <em>erzeugeClosure</em> gibt eine Instanz des funktionalen Interface <em>IntSupplier</em> zurück, die als Lambda angegeben ist. Die <em>main</em>-Methode führt diese zurückgegebene Instanz in einem neuen Thread aus, indem sie ihre <em>getAsInt</em>-Methode ruft. Obwohl der Wert dieser Variable zu diesem Zeitpunkt nicht mehr im Scope liegt, kommt es zur Ausgabe "123". Das ist möglich, weil die Variable in der Closure, die für den Lambda-Ausdruck erzeugt wird, noch vorhanden ist. <strong>Der Lambda-Ausdruck ist das, was Sie in Ihrem Code niederschreiben. Erst zur Laufzeit wird daraus und aus der Ausführungsumgebung eine Closure.</strong></p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Lambda-Ausdrücke Teil 1</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/lambda-ausdruecke.html"/>
        <id>https://www.finecloud.ch/lambda-ausdruecke.html</id>
            <category term="softwareentwicklung"/>
            <category term="lambda"/>
            <category term="java"/>
            <category term="dev"/>

        <updated>2022-05-29T15:04:11+02:00</updated>
            <summary>
                <![CDATA[
                    Seit Java 8 können mit Lambda Expressions Funktionen komfortabler, kürzer und lesbarer ausgedrückt werden. Nachfolgend ein Beispiel von Java Code. Dieses Stück Code sucht aus Ihrer Musiksammlung die 100 längsten Songs heraus, die Sie mit mehr als vier Sternen bewertet haben und deren Interpret Ihnen&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Seit Java 8 können mit Lambda Expressions Funktionen komfortabler, kürzer und lesbarer ausgedrückt werden.</p>
<p>Nachfolgend ein Beispiel von Java Code. Dieses Stück Code sucht aus Ihrer Musiksammlung die 100 längsten Songs heraus, die Sie mit mehr als vier Sternen bewertet haben und deren Interpret Ihnen nicht bekannt ist, und berechnet die Gesamtlänge dieser Songs:</p>
<p><code>List&lt;Song&gt; songs = …;</code><br><code>int sekunden = 0;</code><br><code>Sekunden</code><br><code>Collections.sort(songs, new Comparator&lt;Song&gt;(){</code><br><code>    @Override</code><br><code>    public int compare(Song o1, Song o2) {</code><br><code>        return o1.getLaengeInSekunden() - o2. getLaengeInSekunden ();</code><br><code>    }</code><br><code>});</code><br><code>int zaehler = 0;</code><br><code>for (Song song : songs){</code><br><code>    if (song.getSterne() &gt; 4 </code><br><code>            &amp;&amp; ("Unbekannter Künstler".equals(song.getInterpret())){</code><br><code>        sekunden += song.getLaengeInSekunden();</code><code></code><br><code>        if (++zaehler &gt; 100) break;</code><br><code>    }</code><br><code>}</code></p>
<p>Nachfolgend der Java Code der den gleichen Zweck erfüllt, aber Lambda Ausdrücke verwendet:</p>
<p><code>int sekunden = songs.stream()</code><br><code>    .filter(song -&gt; "Unbekannter Künstler".equals(song.getInterpret()))</code><br><code>    .filter(song -&gt; song.getSterne() &gt; 4)</code><br><code>    .sorted(Comparator.comparing(Song::getLaengeInSekunden).reversed())</code><br><code>    .limit(100)</code><br><code>    .mapToInt(Song::getLaengeInSekunden)</code><br><code>    .sum();</code></p>
<p>Die Vorteile liegen auf der Hand: Abgesehen von der Zeilen und Codelänge ist der Code auch viel einfach verständlich, schnell lässt sich erkennen, was der Code bewirkt. In den ersten beiden Zeilen wird die Liste gefiltert (filter), danach sortiert (sorted), auf die 100 ersten Ergebnisse beschränkt (limit), jeder Song auf sein int-Feld laengeInSekunden abgebildet (mapToInt) und von den Längen schliesslich die Summe (sum) berechnet</p>
<h3>Was sind Lambda-Ausdrücke?</h3>
<p>Es handelt sich dabei um Javas Sprachmittel, um Funktionen auszudrücken, im Gegensatz dazu stehen die prozedualen Konstrukte wie Verzweigungen und Schleifen, mit denen der Programmierablauf dargestellt wird. Lambda-Ausdrücke erlauben es zusammen mit entsprechenden APIs im Code nur das Wesentliche zu schreiben, ohne dabei jedes Mal das Übliche wiederholen zu müssen. Das Wesentliche ist eine Liste von Songs zu filtern. Das Übliche wäre in diesem Fall, über eine Liste zu iterieren und jedes Element zu prüfen.</p>
<p>Ohne Lambda-Ausdrücke wird der Code länger, wenige gut lesbar und Fehleranfälliger, denn in Schleifen und Prüfungen schleichen sich gerne Fehler ein.</p>
<h3>Die Lambda-Syntax</h3>
<p>Lambda-Ausdrücke sind auf den ersten Blick als solche erkennbar durch den Pfeil -&gt;, der vorkommen muss und in Java keine andere Bedeutung hat.</p>
<p><code>(Song song) -&gt; {</code><br><code>    return "Unbekannter Künstler".equals(song.getInterpret());</code><br><code>}</code></p>
<p>Links vom Pfeil stehen die Parameter und rechts vom Pfeil steht, was mit diesen parametern geschehen soll. Mehrere Parameter werden, genau wie bei einer Methodendeklaration auch durch Kommas getrennt.</p>
<p>Doch es geht noch kürzer. Es dürfen auch die Parametertypen wegfallen:</p>
<p><code>(song) -&gt; {</code><br><code>    return "Unbekannter Künstler".equals(song.getInterpret());</code><br><code>}</code></p>
<p>Der Java-Compiler ist inzwischen sehr gut darin, Typen aus dem Kontext zu erkennen. Da wir mit einer List&lt;Song&gt; arbeiten und daraus ein Stream&lt;Song&gt; wird, ist für den Compiler klar, dass der Typ des Rückgabewerts auch ein Song sein muss.</p>
<p>Weiter darf, wenn der Lambda-Ausdruck nur ein Parameter benötigt die Klammer um den Parameter herum entfallen:</p>
<p><code>song -&gt; {</code><br><code>    return "Unbekannter Künstler".equals(song.getInterpret());</code><br><code>}</code></p>
<p>Wenn der Ausdruck allerdings keine Parameter hat, muss die Klammer wieder hin. Beispielsweise kann () -&gt; 3 ein gültiger Lambda-Ausdruck sein, der keine Parameter erwartet und die Zahl 3 zurückgibt.</p>
<p>Als letzte Verkürzungsregel darf, wenn ein Rumpf eines Ausdrucks nur aus einem Ausdruck besteht, also einer einzigen Anweisung, die zu einem Wert ausgewertet wird (Vergleich, Berechnung oder Methodenaufruf) nur der Wert-Ausdruck selbst angegeben werden, ohne geschweifte Klammern, ohne Semikolon und ohne return:</p>
<p><code>song -&gt; "Unbekannter Künstler".equals(song.getInterpret())</code></p>
<p>Dabei gibt es aber keine Zwischenschritte, entweder man gibt den Ausdruck wie im letzten Beispiel an, oder man muss den Ausdruck mit geschweiften Klammern, Semikolon und return angeben. Natürlich ist die kürzeste Version anzustreben. Deshalb sollte immer auf die Blockschreibweise verzichtet werden, ausser man hat mehr als ein Wert-Ausdruck, beispielsweise bei einem if-Statement, hier müssen die äusseren Klammern und Returns geschrieben werden:</p>
<p><code>(s1, s2) -&gt; {</code><br><code>    if (aufsteigend){</code><br><code>        return s1.getLaengeInSekunden() - s2.getLaengeInSekunden();</code><br><code>    } else {</code><br><code>        return s2.getLaengeInSekunden() - s1.getLaengeInSekunden();</code><br><code>    }</code><br><code>}</code></p>
<p>Als letzte Spezialität in diesem Artikel gehe ich auf die Variable aufsteigend ein. Genau wie anonyme innere Klassen können Lambdas auf lokale Variabeln ihrer Umgebung zugreifen. Diese lokalen Variablen müssen nicht als final deklariert werden, müssen aber also solche behandelt werden. Das heisst, es reicht aus wenn ihnen im Lambda-Ausdruck oder danach kein neuer Wert mehr zugewiesen wird.</p>
<h3>Methodenreferenz</h3>
<p>Wenn ein Lambda-Ausdruck nur am einzigen übergebenen Parameter eine Methode aufruft und deren Rückgabewert weitergibt, dann kann statt des Lambda-Ausdrucks eine Methodenreferenz angeben werden. Die nachfolgenden Aufrufe haben die gleiche Wirkung:</p>
<p><code>Comparator.comparing(song -&gt; song.getSterne());</code><br><code>Comparator.comparing(Song::getSterne);</code></p>
<p>Methodenreferenzen erkennt man am doppelten Doppelpunkt. Davor steht die Klasse, dahinter die Methode. Wichtig ist, dass man bei der Methodenreferenz keine Klammern nach dem Methodenamen setzt. Das Beispiel von oben ist eine <em>ungebundene Referenz</em>: Sie bezeichnet nicht die getSterne-Methode eines bestimmten Objekts, sondern kann auf beliebige Objekte der Klasse Song angewendet werden. Ist vor dem doppelten Doppelpunkt keine Klasse, sondern eine Objektreferenz, dann ist die Methodenreferenz gebunden und meint immer die Methode dieses einen Objekts.</p>
<p><code>Musicplayer player = new Musicplayer();</code><br><code>songs</code><br><code>        .filter(s -&gt; s. getSterne() == 5)</code><br><code>        .forEach(player::play);</code></p>
<p>Die Referenz player::play meint immer die play-Methode des Musicplayer, den die Variable player referenziert. Mit Lambda-Ausdrücken, aber ohne Methodenreferenz, sähe das Beispiel dann so aus:</p>
<p><code>Musicplayer player = new Musicplayer();</code><br><code>songs</code><br><code>        .filter(s -&gt; s. getSterne() == 5)</code><br><code>        .forEach(s -&gt; player.play(s));</code></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Java Maps</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/java-die-pecs-regel.html"/>
        <id>https://www.finecloud.ch/java-die-pecs-regel.html</id>
            <category term="softwareentwicklung"/>
            <category term="maps"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="collection"/>

        <updated>2022-05-28T20:17:04+02:00</updated>
            <summary>
                <![CDATA[
                    Maps werden auf Deutsch auch als assoziative Arrays bezeichnet. Ein Array ordnet ein Objekt einer Zahl zu, dem Index. Eine Map ordnet ein Objekt, den Wert, einem anderen Objekt zu, dem Schlüssel. Damit ist es möglich Zuordnungen von einem beliebigen Typ zu einem beliebigen anderen&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Maps werden auf Deutsch auch als <em>assoziative Arrays</em> bezeichnet. Ein Array ordnet ein Objekt einer Zahl zu, dem Index. Eine Map ordnet ein Objekt, den Wert, einem anderen Objekt zu, dem Schlüssel. Damit ist es möglich Zuordnungen von einem beliebigen Typ zu einem beliebigen anderen Typ vorzunehmen. Häufig werden Strings als Schlüssel verwendet, es kann aber jeder Objekttyp als Schlüssel dienen.</p>
<p>Eine Map besteht aus zwei Typparameter, den ersten für den Schlüssel und den zweiten für den Wert. Die Map wordCount ist eine Zuordnung von einem String-Schlüssel zu einem Integer-Wert, es ist die am häufigsten verwendete Implementierung von Map:</p>
<p><code>private Map&lt;String, Integer&gt; wordCounts = new HashMap&lt;&gt;();</code><br><code>  private void count(InputStream source){</code><br><code>    try(Scanner scan = new Scanner(source)){</code><br><code>        scan.useDelimiter("[^\\p{IsAlphabetic}]+");</code><br><code>        while (scan.hasNext()){</code><br><code>            String word = scan.next().toLowerCase();</code><br><code>            totalCount++;</code><br><code>            wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);</code><br><code>        }</code><br><code>    }    </code><br><code>}</code></p>
<p>Die put-Methode fügt ein Element hinzu (falls bereits ein Element zugeordnet ist, wird es Überschrieben), die get-Methode gibt den einem Schlüssel zugeordneten Wert zurück. GetOrDefault hat dieselbe Funktion, nur das zusätzlich ein Default-Wert übergeben werden kann, der zurückgegeben wird, falls der angegebene Schlüssel nicht in der Map enthalten ist.</p>
<p>Hier ein weiteres Beispiel einer Geburtstagsliste:</p>
<p><code>public class Geburtstagsliste {</code><br><code>    private Map&lt;String, LocalDate&gt; geburtstage = new TreeMap&lt;&gt;();</code><br><code>    </code><br><code>    public void fuegeGeburtstagHinzu(String name, LocalDate geburtstag){</code><br><code>        geburtstage.put(name, geburtstag);</code><br><code>    }</code><br><code>    </code><br><code>    public LocalDate findeGeburtstag(String name){</code><br><code>        return geburtstage.get(name);</code><br><code>    }</code><br><code>    </code><br><code>    public void schreibeGeburtstage(){</code><br><code>        for(Map.Entry&lt;String, LocalDate&gt; entry : geburtstage.entrySet()){</code><br><code>            System.out.println(entry.getKey() + ": " + entry.getValue());</code><br><code>        }</code><br><code>    }</code><br><code>}</code></p>
<p>Ein weiteres Feature von Map ist, dass man über eine Map iterieren kann:</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td style="width: 49.9288%;"><strong>Methode</strong></td>
<td style="width: 49.9288%;"><strong>Funktion</strong></td>
</tr>
<tr>
<td style="width: 49.9288%;">entrySet</td>
<td style="width: 49.9288%;">Liefert ein Set von Map.Entry-Objekten, die Key (Schlüssel) und Value (Wert) eines Eintrags enthalten</td>
</tr>
<tr>
<td style="width: 49.9288%;">keySet</td>
<td style="width: 49.9288%;">Liefert eine Collection aller Schlüssel</td>
</tr>
<tr>
<td style="width: 49.9288%;">values</td>
<td style="width: 49.9288%;">Liefert eine Collection aller Werte</td>
</tr>
</tbody>
</table>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Genereische Java Methoden und beschränkte Typen</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/java-genereische-methoden-und-beschraenkte-typen.html"/>
        <id>https://www.finecloud.ch/java-genereische-methoden-und-beschraenkte-typen.html</id>
            <category term="softwareentwicklung"/>
            <category term="parameterlisten"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="collectionlist"/>
            <category term="collection"/>

        <updated>2022-05-28T20:17:55+02:00</updated>
            <summary>
                <![CDATA[
                    Eine Methode kann einen typisierten Parameter erzwingen und einen typisierten Wert zurückgeben: public List&lt;Integer&gt; parseAlleInts(List&lt;String&gt; strings){ List&lt;Integer&gt; ergebnis = new ArrayList&lt;&gt;(); for (String s : strings){ ergebnis.add(Integer.parseInt(s)); } return ergebnis; } So ist es möglich eine Liste von Strings als Paramter in eine Liste von&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Eine Methode kann einen typisierten Parameter erzwingen und einen typisierten Wert zurückgeben:</p>
<p><code>public List&lt;Integer&gt; parseAlleInts(List&lt;String&gt; strings){        </code><br><code>    List&lt;Integer&gt; ergebnis = new ArrayList&lt;&gt;();</code><br><code>    for (String s : strings){</code><br><code>        ergebnis.add(Integer.parseInt(s));</code><br><code>    }</code><br><code>    return ergebnis;</code><br><code>}</code></p>
<p>So ist es möglich eine Liste von Strings als Paramter in eine Liste von Zahlen (Integern) umzuwandeln.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Java Collection Iteratoren</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/java-collection-iteratoren.html"/>
        <id>https://www.finecloud.ch/java-collection-iteratoren.html</id>
            <category term="softwareentwicklung"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="collectioniterator"/>
            <category term="collection"/>
            <category term="array"/>

        <updated>2022-05-26T14:18:44+02:00</updated>
            <summary>
                <![CDATA[
                    Diese Collection Methode kann dazu verwendet werden, über alle Werte einer Collection zu iterieren: die Methode iterator, gibt ein Objekt vom Typ Iterator zurück. Mit der Methode hasNext wird geprüft, ob es noch ein weiteres Element in der Collection gibt, next gibt das nächste Element&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Diese Collection Methode kann dazu verwendet werden, über alle Werte einer Collection zu iterieren: die Methode <em>iterator</em>, gibt ein Objekt vom Typ <em>Iterator</em> zurück.</p>
<p>Mit der Methode <em>hasNext</em> wird geprüft, ob es noch ein weiteres Element in der Collection gibt, <em>next</em> gibt das nächste Element zurück:</p>
<p><code>List&lt;Book&gt; books = …;</code><br><code>Iterator&lt;Book&gt; it = books.iterator();</code><br><code>while (it.hasNext){</code><br><code>    Book book = it.next();</code><br><code>    …</code><br><code>}</code></p>
<p>Seit Java 5 und der Einführung der for-each-Schleife ist es nur noch selten nötig, selbst mit dem Interator zu arbeiten. Ein wesentlicher Vorteil ist, dass es keine Sprachkonstrukte, sondern Objekte sind und können als solche in Feldern gespeichert und als Parameter an Methoden übergeben und aus Methoden zurückgegeben werden. Beispielsweise kann damit ein einzelnen Element ausgelesen werden und zu einem späteren Zeitpunkt an derselben Stelle fortgesetzt werden:</p>
<p><code>public boolean spieleHoerbuch(Iterator&lt;Book&gt; books, int zeit) {</code><br><code>    int gesamtzeit = 0;</code><br><code>    while (gesamtzeit &lt; zeit) {</code><br><code>        if (books.hasNext()) {</code><br><code>            Book book = books.next();</code><br><code>            gesamtzeit += book.getLaenge();</code><br><code>            spieleBook(book);</code><br><code>        } else {</code><br><code>            return false;</code><br><code>        }</code><br><code>    }</code><br><code>    return books.hasNext();</code><br><code>}</code></p>
<p>In diesem Beispiel werden solange Hörbücher abgespielt, bis eine Gesamtzeit erreicht ist, dann wird das aktuelle Hörbuch zu ende gespielt. Wenn Sie die Methode das nächste Mal aktivieren, dann übergeben Sie denselben Iterator und es geht mit dem nächsten Hörbuch weiter.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Java Collection Sets</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/java-collection-sets.html"/>
        <id>https://www.finecloud.ch/java-collection-sets.html</id>
            <category term="softwareentwicklung"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="collectionset"/>
            <category term="collection"/>
            <category term="array"/>

        <updated>2022-05-26T14:03:21+02:00</updated>
            <summary>
                <![CDATA[
                    Sets eignen sich für die Bearbeitung einer mathematischen Menge. Set kann somit keine identische Elemente enthalten und kann keine interneReihenfolge haben. Deshalb gibt es für Set auch keine Methoden die den direkten Zugriff auf ein Element ermöglichen. Um auf ein Element eines Set zuzugreifen muss&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Sets eignen sich für die Bearbeitung einer mathematischen Menge. Set kann somit keine identische Elemente enthalten und kann keine interneReihenfolge haben. Deshalb gibt es für Set auch keine Methoden die den direkten Zugriff auf ein Element ermöglichen. Um auf ein Element eines Set zuzugreifen muss darüber iteriert werden:</p>
<p><code>Set&lt;String&gt; besuchteOrte = new HashSet&lt;&gt;();</code><br><code>besuchteOrte.add("Bern");</code><br><code>besuchteOrte.add("Basel");</code><br><code>besuchteOrte.add("Bern");</code><br><code>besuchteOrte.add("Bellinzona");</code><br><code>for (String ort : besuchteOrte){</code><br><code>    System.out.println(ort);</code><br><code>}</code></p>
<p>Im Beispiel wird Bern nur einmal ausgegeben, auch wenn Bern zweimal hinzugefügt wurde, zählt es nur einmal. Beim Hinzufügen ein neuen Elementen mit der add-Methode, gibt die Collection einen boolean-Wert zurück: Wenn das Element hinzugefügt wurde, ist der return true, wenn der Wert bereits vorhanden war, false. So kann festgestellt werden, ob ein neues Element hinzugefügt wurde, oder nicht. Wichtig zu beachten ist zudem, dass die Ausgabe eines Collection Sets nicht in einer festgelegen Reihenfolge erfolgt und es auch keine konstante Reihenfolge der Werte in einem Collection Set gibt.</p>
<p>Die Hauptverwendung von Set, ist HashSet, das die Einmaligkeit der enthaltenen Elemente durch deren Hashcode sicherstellt. Wenn man also eine Set Collection verwenden, sollte man unbedingt in der Klasse die Methoden hashCode und equals überschreiben:</p>
<p><code>Set&lt;Book&gt; meineBuecher = new HashSet&lt;&gt;();</code><br><code>meineBuecher.add(new Book("Bretonische Nächte", "Jean-Luc Bannalec", 298));</code><br><code>meineBuecher.add(new Book("Bretonische Nächte", "Jean-Luc Bannalec", 316));</code></p>
<p>Wenn die Klasse Book die hashCode Methode nicht überschreibt, dann ist "Bretonische Nächte" zweimal im Set enthalten, denn die von Object geerbte bashCode-Implementierung gibt für verschiedene Objekte verschiedene Werte zurück, auch wenn die Objekte Inhaltsgleich sind. Deshalb muss eine eigene hashCode-Methode geschrieben werden, die den Code aus Titel, Autor und Seitenzahl berechnet, dann wird das zweite Buch nicht hinzugefügt, weil das Buch jetzt als identisch erkannt wird.</p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Java Collection Listen</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/java-collection-listen.html"/>
        <id>https://www.finecloud.ch/java-collection-listen.html</id>
            <category term="softwareentwicklung"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="collectionlist"/>
            <category term="collection"/>
            <category term="arraylist"/>
            <category term="array"/>

        <updated>2022-05-26T14:44:15+02:00</updated>
            <summary>
                <![CDATA[
                    Listen sind Collections, die am ehesten einem Array entsprechen. Die Elemente bleiben in der Reihenfolge wie sie hinzugefügt werden und sie können auf einzelne Positionen im Index der Liste zugreifen: lesen mit get(index) und schreiben mit set(index, element). Damit ist mit Listen alles möglich, was&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Listen sind Collections, die am ehesten einem Array entsprechen. Die Elemente bleiben in der Reihenfolge wie sie hinzugefügt werden und sie können auf einzelne Positionen im Index der Liste zugreifen: lesen mit <em>get(index) </em>und schreiben mit <em>set(index, element).</em></p>
<p>Damit ist mit Listen alles möglich, was man mit Arrays auch kann, einfach mit mehr Komfort. Die Liste wächst bei neuen Elementen automatisch an und wenn ein Element mit remove entfernt wird, wird die Lücke geschlossen, indem alle nachfolgenden Elemente nachrutschen:</p>
<p><code>List&lt;Book&gt; booklist = new ArrayList&lt;&gt;();</code><br><code>//Der Booklist zwei Books hinzufügen</code><br><code>booklist.add(new Book(…));</code><br><code>booklist.add(new Book(…));</code><br><code>//Das zweite Buch durch ein anderes ersetzen</code><br><code>booklist.set(1, new Book(…));</code><br><code>//Alle Buecher anzeigen</code><br><code>for (Book book : booklist){</code><br><code>    System.out.println(book.getTitel());</code><code></code><br><code>}</code></p>
<p>Für die meisten Fälle ist die ArrayList die performanteste aller List-Implementierungen.</p>
            ]]>
        </content>
    </entry>
</feed>
