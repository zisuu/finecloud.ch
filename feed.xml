<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Finecloud</title>
    <link href="https://www.finecloud.ch/feed.xml" rel="self" />
    <link href="https://www.finecloud.ch" />
    <updated>2022-06-21T09:59:48+02:00</updated>
    <author>
        <name>Finecloud</name>
    </author>
    <id>https://www.finecloud.ch</id>

    <entry>
        <title>Tabby Config-Sync auf Nextcloud einrichten</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/tabby.html"/>
        <id>https://www.finecloud.ch/tabby.html</id>
            <category term="unix"/>
            <category term="tools"/>
            <category term="tabby"/>
            <category term="ssh"/>
            <category term="shell"/>
            <category term="nextcloud"/>
            <category term="linux"/>
            <category term="container"/>

        <updated>2022-06-17T06:44:36+02:00</updated>
            <summary>
                <![CDATA[
                    A terminal for the modern age Tabby ist ein anpassbares, Platform-Übergreifendes Terminal App für die Arbeit mit Lokalen Shells sowie Serial, SSH und Telnet Verbindungen. Aus diesen Gründen ist Tabby viel praktischer und moderner als Putty: Link zum App: https://tabby.sh/ Link zum Projekt auf GitHub:&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h3>A terminal for the modern age</h3>
<p><a href="https://tabby.sh/" rel="nofollow">Tabby</a> ist ein anpassbares, Platform-Übergreifendes Terminal App für die Arbeit mit Lokalen Shells sowie Serial, SSH und Telnet Verbindungen.</p>
<figure class="post__image"><img loading="lazy"  src="https://www.finecloud.ch/media/posts/33/readme-terminal.png" sizes="100vw" srcset="https://www.finecloud.ch/media/posts/33/responsive/readme-terminal-xs.png 300w ,https://www.finecloud.ch/media/posts/33/responsive/readme-terminal-sm.png 480w ,https://www.finecloud.ch/media/posts/33/responsive/readme-terminal-md.png 768w ,https://www.finecloud.ch/media/posts/33/responsive/readme-terminal-lg.png 1024w ,https://www.finecloud.ch/media/posts/33/responsive/readme-terminal-xl.png 1360w ,https://www.finecloud.ch/media/posts/33/responsive/readme-terminal-2xl.png 1600w"  alt="" width="2724" height="1810"></figure>
<p>Aus diesen Gründen ist Tabby viel praktischer und moderner als <a href="https://www.putty.org/" target="_blank" rel="nofollow noopener noreferrer">Putty</a>:</p>
<ul>
<li>Läuft auf Windows, Mac und Linux</li>
<li>Integrierter SSH-Client mit Verbindungsmanager</li>
<li>Integriertes serielles Terminal</li>
<li>Unterstützung für PowerShell, PS Core, WSL, Git-Bash, Cygwin, Cmder und CMD</li>
<li>Volle Unicode-Unterstützung, einschließlich Zeichen mit doppelter Breite</li>
<li>Dateiübertragung von/zu SSH-Sitzungen über SFTP und Zmodem</li>
<li>Thematisierung und Farbschemata</li>
<li>Vollständig konfigurierbare Shortcuts und Multi-Chord-Shortcuts</li>
<li>Erinnert sich an Ihre Registerkarten und geteilten Fenster</li>
<li>Shell-Funktionen wie unter Windows, einschließlich Tab-Vervollständigung</li>
<li>Integrierter verschlüsselter Container für SSH-Secrets und -Konfiguration</li>
</ul>
<p>Link zum App: <a href="https://tabby.sh/">https://tabby.sh/</a></p>
<p>Link zum Projekt auf GitHub: <a href="https://github.com/eugeny/tabby">https://github.com/eugeny/tabby</a> </p>
<h3>Tabby Config Sync mit Nextcloud</h3>
<p class="msg msg--warning">Achtung: So schön das alles klingt, der WebDav Sync mit Nextcloud scheint nicht zu funktionieren. Beim Anlegen der Konfigdatei via WebDav erscheint ein unspezifischer Fehler. Solange das Problem noch nicht behoben ist, muss man wohl mit alternativen auskommen wie FTPS oder manuelles kopieren der Datei auf einen Nextcloud-Share.</p>
<p>Doch was bringt das alles ohne Config Sync zwischen deinen einzelnen Geräten, Windows, MacOS und Linux. Dafür kannst du entweder den Server von Tabby verwenden, oder andere 3rd Party Backends. Noch toller ist aber, dass du deine eigene Nextcloud mittels DAV Protokoll verwenden kannst, um die Konfiguration zwischen deinen Geräten zu synchronisieren:</p>
<h5>Vorbereitungen auf Nextcloud</h5>
<ol>
<li>Aus Sicherheitsgründen empfehle ich für den ConfigSync einen separaten Benutzer Account explizit nur für diesen ConfigSync zu erstellen.</li>
<li>Melde dich mit dem neuen Benutzer an deiner Nextcloud an und erstelle einen neuen leeren Ordner "TabbyConfigSync".</li>
<li>Optional kannst du unter den Security Einstellungen des Benutzers noch ein App Passwort generieren - damit kannst du den Zugriff auf das DAV Protokoll beschränken. Mit dem App Passwort ist eine Anmeldung am Nextcloud WebInterface nicht möglich.</li>
</ol>
<h5>Einstellungen in der Tabby App</h5>
<ol>
<li>Installiere das Tabby Plugin "cloud-settings-sync" Quelle: <a href="https://tabby-cloud.tranit.co/">https://tabby-cloud.tranit.co/</a> <br><figure class="post__image"><img loading="lazy"  src="https://www.finecloud.ch/media/posts/33/Screenshot-2022-06-14-at-22.13.16.png" sizes="100vw" srcset="https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.13.16-xs.png 300w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.13.16-sm.png 480w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.13.16-md.png 768w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.13.16-lg.png 1024w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.13.16-xl.png 1360w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.13.16-2xl.png 1600w"  alt="" width="1754" height="1094"></figure></li>
<li>Klicke auf "Get" um das Plugin zu installieren:<br><figure class="post__image"><img loading="lazy"  src="https://www.finecloud.ch/media/posts/33/Screenshot-2022-06-14-at-22.15.00.png" sizes="100vw" srcset="https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.15.00-xs.png 300w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.15.00-sm.png 480w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.15.00-md.png 768w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.15.00-lg.png 1024w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.15.00-xl.png 1360w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.15.00-2xl.png 1600w"  alt="" width="1754" height="1094"></figure></li>
<li>Beende die App und starte sie neu, damit das Plugin aktiv wird</li>
<li>Nun ist ein neuer Reiter in den Einstellungen "Settings Sync", gib hier die folgenden Einstellungen an:
<ul>
<li>URL: <a href="https://nextcloud.domain.com">https://nextcloud.domain.com</a></li>
<li>User: useraccount</li>
<li>Password: dein App-Passwort</li>
<li>Port: 443</li>
<li>Pfad: /remote.php/dav/files/useraccount/TabbyConfigSync<br><figure class="post__image post__image--wide"><img loading="lazy"  src="https://www.finecloud.ch/media/posts/33/Screenshot-2022-06-14-at-22.57.05.png" sizes="100vw" srcset="https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.57.05-xs.png 300w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.57.05-sm.png 480w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.57.05-md.png 768w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.57.05-lg.png 1024w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.57.05-xl.png 1360w ,https://www.finecloud.ch/media/posts/33/responsive/Screenshot-2022-06-14-at-22.57.05-2xl.png 1600w"  alt="" width="1913" height="693"></figure></li>
<li>Klicke anschliessend auf den Button "Test Connection"</li>
</ul>
</li>
<li>Sofern deine Einstellungen korrekt sind, Klicke auf "Save This Setting". Nun kannst du nun auf der rechten Seite noch den Sync aktivieren.</li>
<li>Richte diese Konfiguration auf allen deinen Geräten so ein und deine Config ist auf allen Geräten immer aktuell.</li>
</ol>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Netzwerkkommunikation mit Java</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/netzwerkkommunikation-mit-java.html"/>
        <id>https://www.finecloud.ch/netzwerkkommunikation-mit-java.html</id>
            <category term="writer"/>
            <category term="softwareentwicklung"/>
            <category term="socket"/>
            <category term="reader"/>
            <category term="network"/>
            <category term="java.io"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="bufferedwriter"/>

        <updated>2022-06-21T09:59:48+02:00</updated>
            <summary>
                <![CDATA[
                    In Java gibt es keinen nennenswerten Unterschied wischen I/O mit Daten und I/O mit Netzwerkverbindungen. In beiden Fällen basiert die Ein- und Ausgabe auf InputStream und OutputStream, der Unterschied liegt nur darin, wo diese Datenströme herkommen. Bei der Netzwerkkommunikation mit dem TCP-Protokoll kommen sie aus&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>In Java gibt es keinen nennenswerten Unterschied wischen I/O mit Daten und I/O mit Netzwerkverbindungen. In beiden Fällen basiert die Ein- und Ausgabe auf InputStream und OutputStream, der Unterschied liegt nur darin, wo diese Datenströme herkommen. Bei der Netzwerkkommunikation mit dem TCP-Protokoll kommen sie aus einem Socket. Bei UDP wird die Klasse DatagramSocket verwendet, welche nicht auf Streams basiert.</p>
<p>Socket hat zwar eine lange Liste von Methoden, aber bei der grundlegenden Verwendung kann man die meisten davon ignorieren.</p>
<h3>Client-Seite</h3>
<p><code class="language-java">
		String nachricht = in.readLine();
		try (Socket verbindung = new Socket("localhost", 23456)){
		    BufferedReader reader = new BufferedReader(
		     new InputStreamReader(verbindung.getInputStream())); 
		    BufferedWriter writer = new BufferedWriter(
		     new OutputStreamWriter(verbindung.getOutputStream()));
		    writer.write(nachricht);
		    writer.newLine();
		    writer.flush();
		    String antwort = reader.readLine();
		}
	</code></p>
<p>Im Beispiel wird dem Socket im Konstruktor Adresse (IP oder Hostname) und Port des Servers angegeben, mit dem eine Verbindung hergestellt werden soll. Die Verbindung wird automatisch hergestellt und mit den Methoden getInputStream und getOutputStream kann man Daten vom Server empfangen und zum Server senden.</p>
<p>Einen kleinen Unterschied zwischen Netzwerk I/O und Datei I/O gibt es mit der flush-Methode. Sie sorgt dafür, dass der Schreibpuffer sofort weiterverarbeitet wird, auch wenn er noch nicht voll ist. Dabei wird der Strom aber nicht sofort geschlossen, denn es sollen nicht nur Daten in eine Richtung versendet werden, es soll echte Kommunikation in beide Richtungen stattfinden. Damit der Server eine Antwort schicken kann, die dann mit readLine gelesen werden kann, muss er zunächst die Nachricht vom Client erhalten und dazu muss der Client den Puffer leeren.</p>
<p>Ausserdem wird weder InputStream noch OutputStream geschlossen. Beide sind fest mit dem Socket verbunden, aus dem sie hergestellt wurden und wenn man einen der Ströme schliesst, wird auch der Socket geschlossen. Andersherum werden die Datenströme aber auch geschlossen, wenn man den Socket schliesst, deswegen reicht es, diesen als Ressource für den try-Block anzugeben.</p>
<h3>Server-Seite</h3>
<p>Ein einfaches Serverprogramm in Java zu schreiben, ist kaum anders als beim Client, nur die Herkunft des Sockets ändert sich:</p>
<p><code class="language-java">
		ServerSocket server = new ServerSocket(23456);
		try (Socket verbindung = server.accept()){
		    BufferedReader reader = new BufferedReader(
		     new InputStreamReader(verbindung.getInputStream())); 
		    BufferedWriter writer = new BufferedWriter(
		     new OutputStreamWriter(verbindung.getOutputStream()));
		    String nachricht = reader.readLine();
		    writer.write(antwort);
		    writer.flush();
		}
	</code></p>
<p>Ein ServerSocket dient nicht direkt der Kommunikation, er wartet nur auf eingehende Verbindungen. Der Konstruktor-Parameter gibt den Port an, auf dem Verbindungen akzeptiert werden sollen; die Methode accept wartet, bis auf diesem Port eine Verbindung hergestellt wird. Und warten heisst hier wirklich warten: accept blockiert so lange, bis eine Verbindung zustande kommt. Wenn dies der Fall ist, gibt accept einen Socket zurück, mit dem man genauso verfahren kann, wie mit einem Socket auf der Client-Seite.</p>
<p>Wie demonstriert, wird nur eine Verbindung akzeptiert und verarbeitet. Für ein Beispiel ausreichend, werden für einen echten Serverprozess dagegen üblicherweise Verbindungen in einer Schleife akzeptiert und die Verarbeiten wird in einem neuen Thread durchgeführt, so dass dieser Thread erneut mit accept auf Verbindungen warten kann.</p>
<p>Hier ein Beispiel-Code für ServerSocket mit Threads:</p>
<p><code class="language-java">
    ServerSocket server = new ServerSocket(23456);
while(!beendet){
    try (Socket verbindung = server.accept()){
        new Thread(() -&gt; verarbeiteVerbidnung(verbindung));
    }
}    </code></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Proxmox VE 7.2 Installation</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/proxmox-ve-72-installation.html"/>
        <id>https://www.finecloud.ch/proxmox-ve-72-installation.html</id>
            <category term="virtualization"/>
            <category term="unix"/>
            <category term="proxmox"/>
            <category term="lxc"/>
            <category term="linux"/>
            <category term="kvm"/>
            <category term="hci"/>
            <category term="container"/>

        <updated>2022-06-09T13:16:03+02:00</updated>
            <summary>
                <![CDATA[
                    Systemanforderungen Proxmox gibt folgende minimale Systemanforderungen an: Für produktive Workloads sind diese Anforderungen aber nicht gedacht. Daher sind die empfohlenen Systemanforderungen wie folgt: Da ich meine Proxmox Infrastruktur zum Start nur als Standalone LAB installieren will und für mein kleines Budget maximal viel Leistung erhalten&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h3 id="mcetoc_1g53sim7k6lt"></h3>
<div class="post__toc">
<h3>Table of Contents</h3>
<ul>
<li><a href="#mcetoc_1g53sim7k6lu">Systemanforderungen</a></li>
<li><a href="#mcetoc_1g53sim7k6lv">Vorbereitung</a>
<ul>
<li><a href="#mcetoc_1g53sim7k6m0">BIOS Einstellungen</a></li>
<li><a href="#mcetoc_1g53sim7k6m1">BIOS Upgrade</a></li>
<li><a href="#mcetoc_1g53sim7k6m2">Installations Medium</a></li>
</ul>
</li>
<li><a href="#mcetoc_1g53sim7k6m3">Installation</a></li>
</ul>
</div>
<h3 id="mcetoc_1g53sim7k6lu">Systemanforderungen</h3>
<p>Proxmox gibt folgende minimale Systemanforderungen an:</p>
<ul>
<li>CPU: 64bit (Intel EMT64 or AMD64)</li>
<li>Intel VT/AMD-V capable CPU/Mainboard for KVM full virtualization support</li>
<li>RAM: 1 GB RAM, plus additional RAM needed for guests</li>
<li>Hard drive</li>
<li>One network card (NIC)</li>
</ul>
<p>Für produktive Workloads sind diese Anforderungen aber nicht gedacht. Daher sind die empfohlenen Systemanforderungen wie folgt:</p>
<ul>
<li>Intel EMT64 or AMD64 with Intel VT/AMD-V CPU ﬂag</li>
<li>Memory: Minimum 2 GB for the OS and Proxmox VE services, plus designated memory for guests. For Ceph and ZFS, additional memory is required; approximately 1GB of memory for every TB of used storage</li>
<li>Fast and redundant storage, best results are achieved with SSDs</li>
<li>OS storage: Use a hardware RAID with battery protected write cache (“BBU”) or non-RAID with ZFS (optional SSD for ZIL)</li>
<li>VM storage:
<ul>
<li>For local storage, use either a hardware RAID with battery backed write cache (BBU) or non-RAID for ZFS and Ceph. Neither ZFS nor Ceph are compatible with a hardware RAID controller</li>
<li>Shared and distributed storage is possible</li>
</ul>
</li>
<li>Redundant (Multi-)Gbit NICs, with additional NICs depending on the preferred storage technology and cluster setup.</li>
<li>For PCI(e) passthrough the CPU needs to support the VT-d/AMD-d ﬂag.</li>
</ul>
<p>Da ich meine Proxmox Infrastruktur zum Start nur als Standalone LAB installieren will und für mein kleines Budget maximal viel Leistung erhalten will, geht das nur auf Kosten von Redundanz und Verfügbarkeit, deshalb habe ich mich zum Start für folgende Hardware entschieden:</p>
<ul>
<li>Intel NUC10i7FNHN Barebone</li>
<li>Kingston SO-DDR4-RAM 32GB</li>
<li>Samsung SSD 970 EVO Plus NVMe M.2 500GB</li>
</ul>
<h3 id="mcetoc_1g53sim7k6lv">Vorbereitung</h3>
<h4 id="mcetoc_1g53sim7k6m0">BIOS Einstellungen</h4>
<p>Bevor wir mit der Installation starten, muss im BIOS des NUC überprüft werden ob die Virtualisierungs-Unterstützung des Prozessors aktiviert ist, dazu müssen folgende Settings aktiviert sein:</p>
<ul>
<li>Performance &gt; Processor &gt; Hyper-Threading (enabled)</li>
<li>Performance &gt; Processor &gt; Intel Turbo Boost Technology (checked)</li>
</ul>
<p>Secure Boot schalten wir aus:</p>
<ul>
<li>Boot &gt; Secure Boot &gt; Secure Boot &gt; Disabled</li>
</ul>
<p>Weiter empfiehlt es sich die Boot Reihenfolge so anzupassen das USB Geräte an erster Stelle kommen. Dazu unter:</p>
<ul>
<li>Boot &gt; Boot Priority &gt; Boot USB Devices Frist</li>
</ul>
<h4 id="mcetoc_1g53sim7k6m1">BIOS Upgrade</h4>
<p>Von einem pauschalen BIOS Upgrade habe ich abgesehen, da Intel die Frage "Wann soll ich ein BIOS Update machen?" wie folgt beantwortet:</p>
<blockquote>
<p>Update the BIOS on your computer only if the newer BIOS version can solve a specific problem. We don't recommend BIOS updates for computers that do not need it. </p>
<p>Quelle: <a href="https://www.intel.com/content/www/us/en/support/articles/000006714/intel-nuc.html" target="_blank" rel="nofollow noopener noreferrer">https://www.intel.com/content/www/us/en/support/articles/000006714/intel-nuc.html</a></p>
</blockquote>
<h4 id="mcetoc_1g53sim7k6m2">Installations Medium</h4>
<p>Proxmox empfiehlt die Installation via ISO File mittels einem USB Flash Drive. Dazu muss aber das ISO File zuerst in ein Image konvertiert werden, damit wir dieses Image so auf den USB Stick schreiben können, damit wir davon booten können. Unter MacOS geht das am einfachsten so:</p>
<ol>
<li>Neues Terminal öffnen (suche nach Terminal in Spotlight)</li>
<li>Konvertieren der .iso Datei nach .dmg:<br><code># hdiutil convert -format UDRW -o proxmox-ve_*.dmg proxmox-ve_*.iso</code></li>
<li>Damit wir eine aktuelle Liste der verfügbaren Geräte erhalten:<br><code># diskutil list</code></li>
<li>Nun stecken wir den USB Stick ein und geben den vorherigen Befehl nochmals ein, damit wir herausfinden können, welche Gerätebezeichnung vergeben wurde. (sollte etwas mit, /dev/diskX sein).<br><code># diskutil list</code><br><code># diskutil unmountDisk /dev/diskX</code></li>
<li>Nun schreiben wir das Image auf den USB Stick. Achtung: das X muss mit der Disk Nummer des letzten Befehls ersetzt werden. (rdiskX anstelle von diskX ist Absicht, das erhöht die Schreibgeschwindikeit):<br><code># sudo dd if=proxmox-ve_*.dmg of=/dev/rdiskX bs=1m</code></li>
</ol>
<h3 id="mcetoc_1g53sim7k6m3">Installation</h3>
<p>Zum Start des Installations wizards erhält man folgende Optionen:</p>
<ul>
<li>Install Proxmox</li>
<li>Rescue Boot</li>
<li>Test Memory</li>
</ul>
<p>Mit <em>Install Proxmox</em> kann die Installation gestartet werden. Nachdem die ELUA akzeptiert wurde, müssen wir uns Entscheiden welches Filesystem wir verwenden wollen und auf welche Harddisk Proxmox installiert werden soll. <strong>Da ich nur eine NVMe SSD habe, gibt es nur diese Auswahl der Disk. Als Filesystem will ich ein ZFS ausprobieren, was eigentlich normalerweise erst bei mehreren Disks sinnvoll ist.</strong></p>
<p><strong>Obwohl ZFS mehr Memory frisst (angeblich muss man mit mindestens Pauschal 4GB rechnen plus 1GB Memory pro TB Raw Datenspeicher) möchte ich auf die folgenden ZFS Vorteile welche in Proxmox angeblich nur mit ZFS integriert nicht verzichten:</strong></p>
<ul>
<li><strong>Encryption</strong></li>
<li><strong>Snapshots/Backups</strong></li>
<li><strong>Compression</strong></li>
</ul>
<p>Da ich aber nur eine Disk habe verzichte ich auf einen RAID Level, und nehme die Option: <em>zfs (RAID0)</em></p>
<p>Als nächstes werden die <em>Location and Time Zone</em> definiert. Weiter muss ein Kennwort definiert werden für den Proxmox root Account, bevor die Netzwerk Angaben angefragt werden und schliesslich die Installation gestartet werden kann.</p>
<p>Sobald die Installation erfolgt ist, kann das Proxmox Web-UI von einem anderen Gerät aus unter <em>https://&lt;proxmox-ip&gt;:8006/ </em>geöffnet werden.</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Proxmox VE 7.2 Übersicht</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/proxmox-ve-intro.html"/>
        <id>https://www.finecloud.ch/proxmox-ve-intro.html</id>
            <category term="virtualization"/>
            <category term="unix"/>
            <category term="proxmox"/>
            <category term="lxc"/>
            <category term="linux"/>
            <category term="kvm"/>
            <category term="hci"/>
            <category term="container"/>

        <updated>2022-06-08T15:46:47+02:00</updated>
            <summary>
                <![CDATA[
                    Die Architektur Proxmox VE ist eine Plattform zum Betrieben von virtuellen Maschinen und Container. Dabei ist die gesamte Proxmox VE Plattform open source und baisert auf Debian Linux. die VE Plattform besteht aus zwei virtualisierungs-technologien: Proxmox gibt es als single node, oder als Cluster mit&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>Table of Contents</h3>
<ul>
<li><a href="#mcetoc_1g4tdpel45mg">Die Architektur</a></li>
<li><a href="#mcetoc_1g4tdhqsl5l5">Zentrales Management</a></li>
<li><a href="#mcetoc_1g4tdhqsl5l6">Storage</a></li>
<li><a href="#mcetoc_1g4tdhqsl5l7">Backup und Restore</a></li>
<li><a href="#mcetoc_1g4tdhqsl5l8">High Availability Cluster</a></li>
<li><a href="#mcetoc_1g4tdhqsl5l9">Networking</a></li>
<li><a href="#mcetoc_1g4tdhqsl5la">Firewall</a></li>
<li><a href="#mcetoc_1g4tdhqsl5lb">Hyper-converged Infrastructure (HCI)</a>
<ul>
<li><a href="#mcetoc_1g4tdlsh25m7">HCI Storage</a></li>
</ul>
</li>
<li><a href="#mcetoc_1g4tdcg765ga">Feature Übersicht</a></li>
</ul>
</div>
<h3 id="mcetoc_1g4tdpel45mg">Die Architektur</h3>
<p><img loading="lazy" src="https://www.finecloud.ch/media/posts/22/Screenshot-2022-06-06-at-23.00.20.png" sizes="100vw" srcset="https://www.finecloud.ch/media/posts/22/responsive/Screenshot-2022-06-06-at-23.00.20-xs.png 300w ,https://www.finecloud.ch/media/posts/22/responsive/Screenshot-2022-06-06-at-23.00.20-sm.png 480w ,https://www.finecloud.ch/media/posts/22/responsive/Screenshot-2022-06-06-at-23.00.20-md.png 768w ,https://www.finecloud.ch/media/posts/22/responsive/Screenshot-2022-06-06-at-23.00.20-lg.png 1024w ,https://www.finecloud.ch/media/posts/22/responsive/Screenshot-2022-06-06-at-23.00.20-xl.png 1360w ,https://www.finecloud.ch/media/posts/22/responsive/Screenshot-2022-06-06-at-23.00.20-2xl.png 1600w"  alt="Architektur" width="765" height="586"></p>
<p>Proxmox VE ist eine Plattform zum Betrieben von virtuellen Maschinen und Container. Dabei ist die gesamte Proxmox VE Plattform open source und baisert auf Debian Linux. die VE Plattform besteht aus zwei virtualisierungs-technologien:</p>
<ul>
<li>Kernel-based Virtual Machine (KVM)</li>
<li>Container-based virtualization (LXC)</li>
</ul>
<p>Proxmox gibt es als single node, oder als Cluster mit Anzahl n Nodes. Das gesamte Management der Plattform kann über ein Web basiertes Management Interface erfolgen.</p>
<h3 id="mcetoc_1g4tdhqsl5l5">Zentrales Management</h3>
<p>Proxmox ermöglicht es sämtliche Management Arbeiten zentral auszuführen, egal ob es sich um einen Cluster mit n Nodes handelt, oder ob es nur ein Single Node ist.  Damit lässt sich der gesamte Cluster von jedem einzelnen Node aus verwalten. Das JavaScript basierte Web-UI erlaubt die Verwaltung von Storage, Containern sowie den KVM Guest VMs. Darüberhinaus kann über das Web-UI die History, Syslogs, Backup und Restore Jobs, live-migration oder HA Aktivitäten eingesehen werden.</p>
<p>Was Proxmox einmalig macht ist deren Cluster File System: pmxcfs, ein Datenbank getriebener Speicher zum Speichern von Konfigurationsdateien. Mittels corosync werden diese Dateien in Echtzeit zwischen allen Nodes im Cluster repliziert. Das File System speichert alle Daten in einer persistenten Datenbank auf der Disk, unabhängig davon wird eine kopier der Datenbank im RAM, mit einer maximalen Speichergrösse von 30MB abgelegt, was für mehr als tausend VMs ausreicht.</p>
<p>Für fortgeschrittene Anwender kann Proxmox auch via CLI, also Unix Shell oder mit Windows Powershell oder über die Rest-API verwaltet werden. Die API unterstützt JSON als primäres Datenformat.</p>
<p>Für die Authentifizierung unterstützt Proxmox Microsoft Active Directory, LDAP, Linux PAM standard authentifizierung oder den eigenen built-in Proxmox VE auth Server.</p>
<h3 id="mcetoc_1g4tdhqsl5l6">Storage</h3>
<p>Proxmox verfügt über ein sehr flexibles Storage Modell. VM Images können lokal auf einem oder mehreren Local Storages gespeichert werden, oder auf einem shared Storage wie NFS oder einem SAN. Es können sämtliche für Debian Linux verfügbaren Storage-Technologien verwendet werden.</p>
<p>Für den Betrieb eines Clusters sollte man unbedingt einen Shared Storage verwenden um die VMs zu speichern, damit man auch von der live-migrate Funktion gebrauch machen kann. Diese ermöglicht es eine VM im laufenden Betrieb von einem Node auf einen anderen zu verschieben. Dabei haben sämtliche Nodes im Cluster direkten zugriff auf die VM Disk Images. Nachfolgende Liste listet die unterstützten Storage auf:</p>
<p>Netzwerk-Storage:</p>
<ul>
<li>LVM Group (network backing with iSCSI targets)</li>
<li>iSCSI target</li>
<li>NFS Share</li>
<li>CIFS Share</li>
<li>Ceph Share</li>
<li>Directly use iSCSI LUNs</li>
<li>GlusterFS</li>
</ul>
<p>Lokale Storage:</p>
<ul>
<li>LVM Group (local backing devices like block devices, FC devices, DRBD, ect.)</li>
<li>Directory (storage on existing filesystem)</li>
<li>ZFS</li>
</ul>
<h3 id="mcetoc_1g4tdhqsl5l7">Backup und Restore</h3>
<p>Das integrierte Backup Tool names <em>vzdump </em>kreiert konsistente Snapshots von laufenden Containern und KVM Guests. Dabei wird ein Archiv der VM oder Container Daten erstellt, welches auch die Konfiguration der VM/CT beinhaltet.</p>
<h3 id="mcetoc_1g4tdhqsl5l8">High Availability Cluster</h3>
<p>Ein multi-node Proxmox VE HA Cluster erlaubt den Betrieb von hochverfügbaren virtual servers. Der Cluster basiert auf bewährte Linux HA Technologien, welche eine stabile und zuverlässigen HA Service ermöglichen.</p>
<h3 id="mcetoc_1g4tdhqsl5l9">Networking</h3>
<p>Proxmox erlaubt den Einsatz von VLANS (IEEE 802.1q) und Netzwerk bonding/aggregation. Damit ist es möglich auch komplexere, flexible virtuelle Netzwerke für die Proxmox VE Hosts aufzubauen und sämtliche Funktionen des Linux Netzwerk Stacks zu nutzen.</p>
<p>Standardmässig kommt Proxmox mit einem bridge Netzwerkmodel.  Alle VMs können diese bridge verwenden, so als wären alle Guests mit virtuellen Netzwerkkabel zu einem physikalischen Netzwerk zusammengeschlossen. Jeder Netzwerkkarte kann eine TCP/IP Konfiguration zugewiesen werden.</p>
<h3 id="mcetoc_1g4tdhqsl5la">Firewall</h3>
<p>Die integrierte Firewall ermöglicht es Netzwerk Packete von jedem VM oder Container Interface zu filtern. Firewall Rules können in <em>Security Groups</em> gruppiert werden.</p>
<h3 id="mcetoc_1g4tdhqsl5lb">Hyper-converged Infrastructure (HCI)</h3>
<p>HCI Umgebungen sind besonders nützlich für Deployments in einer Infrastruktur mit hohen Anforderungen und tiefem administrations Budget.</p>
<p id="mcetoc_1g4tdlsh25m6">Vorteile von HCI sind:</p>
<ul>
<li>Skalierbarkeit: nahtlose Erweiterung von Computing, Netzwerk und Storage</li>
<li>Tiefe Kosten: Proxmox VE ist open source und integriert alle benötigten Komponenten und kann damit eine teure Computing/Storage Infrastruktur ersetzen</li>
<li>Daten-Schutz und Effizienz: Services wie Backup und Disaster Recovery sind direkt integriert</li>
<li>Kein Vendor-Lock-in dank open source</li>
</ul>
<h4 id="mcetoc_1g4tdlsh25m7">HCI Storage</h4>
<p>Proxmox unterstützt die nahtlose Integration von HCI Storage Infrastrukturen wie ceph oder ZFS.</p>
<ul>
<li>ceph: bietet self-healing und self-managing shared, zuverlässig und hoch skalierbaren Storage.</li>
<li>ZFS: kombiniert File System und Local Volume Manager mit erweitertem Schutz vor Datenkorruption, diversen RAID modi und schnellen und günstigen Snapshots. </li>
</ul>
<h3 id="mcetoc_1g4tdcg765ga">Feature Übersicht</h3>
<ul>
<li>Open source software</li>
<li>Kein Vendor lock-in</li>
<li>Linux kernel</li>
<li>Schnelle installation, einfach zu verwenden</li>
<li>Web-basiertes Management Interface</li>
<li>REST API</li>
<li>Grosse aktive Community</li>
<li>Tiefe Administrationskosten und einfaches deployment</li>
</ul>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Dateien und Verzeichnisse unter Java</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/dateien-und-verzeichnisse-unter-java.html"/>
        <id>https://www.finecloud.ch/dateien-und-verzeichnisse-unter-java.html</id>
            <category term="verzeichnisse"/>
            <category term="softwareentwicklung"/>
            <category term="java.nio.files"/>
            <category term="java.io.file"/>
            <category term="java.io"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="dateien"/>

        <updated>2022-06-06T23:13:08+02:00</updated>
            <summary>
                <![CDATA[
                    Dateioperationen mit java.io werden in Java immer, direkt oder indirekt, durch ein Objekt des Typs java.io.File abgebildet. Dabei kann File aber nicht selbst aus Dateien lesen, oder in sie schreiben, dazu benötigt man einen Reader oder Writer (für Textdateien) resp. einen InputStream oder OutputStream (für&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>Table of Contents</h3>
<ul>
<li><a href="#mcetoc_1g4tdqg1s5n6">Dateien und Pfade</a></li>
<li><a href="#mcetoc_1g4tdqg1s5n7">Dateioperationen aus "Files"</a></li>
<li><a href="#mcetoc_1g4tdqg1s5n8">Verzeichnisse</a></li>
</ul>
</div>
<p>Dateioperationen mit java.io werden in Java immer, direkt oder indirekt, durch ein Objekt des Typs java.io.File abgebildet. Dabei kann File aber nicht selbst aus Dateien lesen, oder in sie schreiben, dazu benötigt man einen Reader oder Writer (für Textdateien) resp. einen InputStream oder OutputStream (für Binärdateien).</p>
<h3 id="mcetoc_1g4tdqg1s5n6">Dateien und Pfade</h3>
<p>Ein File wird immer aus einer Pfadangabe, entweder <em>absolut</em> oder <em>relativ</em> erzeugt. Absolut geht von einem Wurzelverzeichnis aus, zum Beispiel C:\ unter Windows, oder / unter Linux. Ein relativer Pfad bezieht sich dagegen auf das aktuelle Verzeichnis des Benutzers, normalerweise von dort aus woher das Programm aufgerufen wurde. Wenn die Datei unter dem angegebenen Pfad nicht existiert, wird auch keine entsprechende Datei unter dem definierten Pfad angelegt:</p>
<p><code>File windowsDatei = new File("C:\\home\\user\\text.txt");</code><br><code>File linuxDatei = new File("/home/user/text.txt");</code></p>
<p>Pfade werden also je nach OS unterschiedlich angegeben. Für Windows Pfade als Konstante sind effektiv zwei Doppel Backslashes zu verwenden! Solange die Pfadeingabe vom Benutzer selbst kommt, macht das keine Probleme. Wenn aber aus dem Programm heraus Dateipfade erzeugt werden müssen, dann müssen Sie auf diese Details acht geben. Das richtige Zeichen zum trennen von Verzeichnissen in einer Pfadangabe findet sich in der Konstanten File.separator. Damit lässt sich einen Pfad OS unabhängig erstellen: </p>
<p><code>File datei = new File(File.separator + "home" </code><br><code>    + File.separator + "user"</code><br><code>    + File.separator + "text.txt");</code></p>
<p>Unter Unix-basierten Systemen funktioniert dieser Code. Unter Windows bleibt das Problem mit dem Laufwerksbuchstaben. Dazu kann unabhängig vom OS, alle Wurzelverzeichnisse aufgelistet werden. Dazu kennt File die statische Methode listRoots. So lässt sich ein OS unabhängiger Code schreiben:</p>
<p><code>public File waehleWurzel(){</code><br><code>    File[] wurzeln = File.listRoots();</code><br><code>    if (wurzeln.length == 1){</code><br><code>        return wurzeln[0];</code><br><code>    } else {</code><br><code>        System. out.println("Bitte wählen Sie eine Wurzel");</code><br><code>        for (int i = 0; i &lt; wurzeln.length; i++){</code><br><code>            System.out.println(i + ": " + wurzeln[i]);</code><br><code>        }</code><br><code>        int index = liesZahl();</code><br><code>        return wurzeln[index];</code><br><code>    }</code><br><code>}</code></p>
<p>Doch das reicht immer noch nicht ganz, denn unter Windows kann es hier mehrere Einträge geben, je nachdem wieviele Laufwerke vorhanden sind (C:\, D:\ ...). In diesem Fall wird der Benutzer geben, ein Laufwerk auszuwählen. Anschliessend kann ein neues File-Objekt relativ zur ausgewählten Wurzel erzeugt werden, indem dies dem Konstruktor angegeben wird:</p>
<p><code>File wurzel = waehleWurzel();</code><br><code>File datei = new File(wurzel, "home"</code><br><code> + File.separator + "user"</code><br><code> + File.separator + "text.txt");</code></p>
<p>Ob eine Datei überhaupt existiert kann mit der Methode exists überprüft werden. Da ein File lediglich die objektorientierte Repräsentation eines Pfades ist, kann man Files erzeugen, ohne das diese Dateien bereits existieren. Falls keine Datei existiert kann eine neue Datei mit createNewFile oder mit mkdir ein Verzeichnis an der vom Pfad angegebenen Stelle angelegt werden. File liefert weitere Informationen über Dateien:</p>
<table style="border-collapse: collapse; width: 100%; height: 525.297px;" border="1">
<tbody>
<tr style="height: 50.3594px;">
<td style="width: 49.9288%; height: 50.3594px;"><strong>Methode</strong></td>
<td style="width: 49.9288%; height: 50.3594px;"><strong>Funktion</strong></td>
</tr>
<tr style="height: 107.953px;">
<td style="width: 49.9288%; height: 107.953px;">isFile()</td>
<td style="width: 49.9288%; height: 107.953px;">Prüft, ob es sich bei der angegebenen File-Objekt um eine Datei handelt, (oder einen Ordner)</td>
</tr>
<tr style="height: 107.953px;">
<td style="width: 49.9288%; height: 107.953px;">isDirectory()</td>
<td style="width: 49.9288%; height: 107.953px;">Prüft, ob es sich bei der angegebenen File-Objekt um einen Ordner handelt, (oder eine Datei)</td>
</tr>
<tr style="height: 50.3594px;">
<td style="width: 49.9288%; height: 50.3594px;">canRead()</td>
<td style="width: 49.9288%; height: 50.3594px;">Prüft, ob der Benutzer Leserechte hat</td>
</tr>
<tr style="height: 79.1562px;">
<td style="width: 49.9288%; height: 79.1562px;">canWrite()</td>
<td style="width: 49.9288%; height: 79.1562px;">Prüft, ob der Benutzer Schreibrechte hat</td>
</tr>
<tr>
<td style="width: 49.9288%;">canExectue()</td>
<td style="width: 49.9288%;">Prüft, ob der Benutzer Ausführungsrechte hat</td>
</tr>
<tr style="height: 79.1562px;">
<td style="width: 49.9288%; height: 79.1562px;">getName()</td>
<td style="width: 49.9288%; height: 79.1562px;">Liefert den Namen der Datei, ohne vorangehende Pfadangabe</td>
</tr>
<tr style="height: 50.3594px;">
<td style="width: 49.9288%; height: 50.3594px;">getParent()<br>getParentFile()</td>
<td style="width: 49.9288%; height: 50.3594px;">Liefert das übergeordnete Verzeichnis, entweder als String mit getParent oder als Objekt mit getParentFile</td>
</tr>
<tr>
<td style="width: 49.9288%;">lastModified()</td>
<td style="width: 49.9288%;">Liefert das letzte Änderungsdatum der Datei als long</td>
</tr>
<tr>
<td style="width: 49.9288%;">length()</td>
<td style="width: 49.9288%;">Liefert die Grösse der Datei in Byte als long</td>
</tr>
<tr>
<td style="width: 49.9288%;">delete</td>
<td style="width: 49.9288%;">eine Datei löschen</td>
</tr>
<tr>
<td style="width: 49.9288%;">renameTo</td>
<td style="width: 49.9288%;">eine Datei umbenennen</td>
</tr>
</tbody>
</table>
<p>java.io.File stellt jedoch keine Methoden zur Verfügung für das Kopieren oder verschieben von Dateien. Dazu gibt es aber seit Java 7 eine Hilfsklasse aus Files.</p>
<h3 id="mcetoc_1g4tdqg1s5n7">Dateioperationen aus "Files"</h3>
<p>Die Klasse Files ist eine Sammlung von Hilfsmethoden für alles, was mit Dateien zu tun hat. Diese Klasse ist aber nicht im java.io-Package enthalten, sondern nur im java.nio.files. Damit ist es die einzige Klasse aus der Non-Blocking-I/O-API, die man auch beim alltäglichen Umgang mit Dateien regelmässig benutzt.</p>
<p>Da die Hilfsklasse zu der API java.nio.file.Path gehört und nicht zur java.io.File müssen bei jeder Operation die Parameter von File nach Path und die Rückgabewerte, falls Dateien zurückgegeben werden, wieder von Path nach File konvertiert werden. Dabei lassen sich nicht alle Path-Objekte nach File konvertieren, nur solche welche aus einer Operation auf einem File resultieren. Damit sind auch Kopier- und Verschiebeoperationen möglich. Die Verwendung dieser Methode macht mehr Sinn, als eine Eigenentwicklung in Java, da dies nicht nur praktischer ist, sondern auch effizienter die JDL Systemaufrufe verwenden kann.</p>
<p><code>//File nach Path konvertieren</code><br><code>Path quellPath = quelle.toPath();</code><br><code>Path zielPath = ziel.toPath();</code><br><code>//ENTWEDER Datei kopieren</code><br><code>Path ergebnisPath = Files.copy(quellPath, zielPath);</code><br><code>//ODER Datei verschieben</code><br><code>Path ergebnisPath = Files.move(quellPath, zielPath);</code><br><code>//Ergebnis - eigentlich wieder das Ziel - nach File konvertieren</code><br><code>File ergebnis = ergebnisPath.toFile();</code></p>
<h3 id="mcetoc_1g4tdqg1s5n8">Verzeichnisse</h3>
<p>Um den Inhalt von Verzeichnissen zu ermitteln, gibt es die überladene Methode listFiles die zur Files Klasse gehört. Ohne Parameter gibt sie alle im Verzeichnis enthaltenen Dateien zurück. Wenn man nur an bestimmten Dateien interessiert ist, dann sollte man entweder einen FileFilter oder einen FilenameFilter an listFiles übergeben. Die beiden Filterklassen unterscheiden sich nur darin, dass FileFilter das File-Objekt der gefundenen Datei zur Prüfung erhält, FilenameFilter den Dateinamen als String und das aktuelle Verzeichnis. Beide Filter sind funktionale Interfaces und können deshalb auch als Lambdas angegeben werden.</p>
<p><code>//Alle Dateien auflisten</code><br><code>File[] alleDateien = verzeichnis.listFiles();</code><br><code>//Alle Dateien mit der Endung .txt auflisten </code><br><code>File[] textDateien = verzeichnis.listFiles((parent, name) -&gt; </code><br><code> name.endsWith(".txt"));</code><br><code>//Alle Unterverzeichnisse auflisten</code><br><code>File[] unterverzeichnisse = verzeichnis.listFiles(file -&gt; </code><br><code> file.isDirectory());</code></p>
<p>Auch zum Auflisten des Verzeichnisinhalts hat die Klasse Files Hilfsmethoden. list gibt dabei den Inhalt eines Verzeichnisses als einen Stream von Path-Objekten zurück. walk, listet nicht nur den Inhalt des übergebenen Verzeichnisses auf, sondern auch aller Unterverzeichnisse, ist also rekursiv.</p>
<p><code>Files.walk(quelle.toPath()).forEach(System.out::println);</code></p>
<p>Optional kann die Tiefe der rekursiven Auflistung limitiert werden bis zu einer bestimmten Tiefe. walk(quelle, 1) enthält nur den Inhalt des Verzeichnisses selbst, tut also dasselbe wie list. walk(quelle, 2) enthält den Inhalt der Verzeichnisses und seiner direkten Unterverzeichnisse usw.</p>
<p>Weiter kann mit Files.find in einem Verzeichnis und dessen Unterverzeichnisse nach Dateien gesucht werden, die bestimmten Vorgaben entsprechen. Leider ist auch hier dass java.io und java.nio nicht aus einem Guss. So muss man also die Suchkriterien nicht als FileFilter angeben, sondern als BiPredicate, das als Parameter des Path-Objekt der Datei und ein Objekt vom Typ BasicFileAttributes erhält, in dem sich Informationen wie Dateigrösse und letzte Zugriffszeit finden. Das Beispiel zeigt, wie man Dateien, die grösser als 500MB sind, auflisten kann. Der grosse Nachteil von walk und find ist, dass wenn der Zugriff auf ein Verzeichnis nicht möglich ist, brechen sie mit einer Fehlermeldung ab. Es gibt keine Funktion, diesen Methoden beizubringen, bei unlesbaren Verzeichnissen einfach den Fehler zu ignorieren und weiter zu suchen. Deswegen wird häufig dennoch auf File.listFiles zurückgegriffen.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Genereische Java Methoden und beschränkte Typen</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/java-genereische-methoden-und-beschraenkte-typen.html"/>
        <id>https://www.finecloud.ch/java-genereische-methoden-und-beschraenkte-typen.html</id>
            <category term="softwareentwicklung"/>
            <category term="parameterlisten"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="collectionlist"/>
            <category term="collection"/>

        <updated>2022-05-28T20:17:55+02:00</updated>
            <summary>
                <![CDATA[
                    Eine Methode kann einen typisierten Parameter erzwingen und einen typisierten Wert zurückgeben: public List&lt;Integer&gt; parseAlleInts(List&lt;String&gt; strings){ List&lt;Integer&gt; ergebnis = new ArrayList&lt;&gt;(); for (String s : strings){ ergebnis.add(Integer.parseInt(s)); } return ergebnis; } So ist es möglich eine Liste von Strings als Paramter in eine Liste von&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Eine Methode kann einen typisierten Parameter erzwingen und einen typisierten Wert zurückgeben:</p>
<p><code>public List&lt;Integer&gt; parseAlleInts(List&lt;String&gt; strings){        </code><br><code>    List&lt;Integer&gt; ergebnis = new ArrayList&lt;&gt;();</code><br><code>    for (String s : strings){</code><br><code>        ergebnis.add(Integer.parseInt(s));</code><br><code>    }</code><br><code>    return ergebnis;</code><br><code>}</code></p>
<p>So ist es möglich eine Liste von Strings als Paramter in eine Liste von Zahlen (Integern) umzuwandeln.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Java Collection Iteratoren</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/java-collection-iteratoren.html"/>
        <id>https://www.finecloud.ch/java-collection-iteratoren.html</id>
            <category term="softwareentwicklung"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="collectioniterator"/>
            <category term="collection"/>
            <category term="array"/>

        <updated>2022-05-26T14:18:44+02:00</updated>
            <summary>
                <![CDATA[
                    Diese Collection Methode kann dazu verwendet werden, über alle Werte einer Collection zu iterieren: die Methode iterator, gibt ein Objekt vom Typ Iterator zurück. Mit der Methode hasNext wird geprüft, ob es noch ein weiteres Element in der Collection gibt, next gibt das nächste Element&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Diese Collection Methode kann dazu verwendet werden, über alle Werte einer Collection zu iterieren: die Methode <em>iterator</em>, gibt ein Objekt vom Typ <em>Iterator</em> zurück.</p>
<p>Mit der Methode <em>hasNext</em> wird geprüft, ob es noch ein weiteres Element in der Collection gibt, <em>next</em> gibt das nächste Element zurück:</p>
<p><code>List&lt;Book&gt; books = …;</code><br><code>Iterator&lt;Book&gt; it = books.iterator();</code><br><code>while (it.hasNext){</code><br><code>    Book book = it.next();</code><br><code>    …</code><br><code>}</code></p>
<p>Seit Java 5 und der Einführung der for-each-Schleife ist es nur noch selten nötig, selbst mit dem Interator zu arbeiten. Ein wesentlicher Vorteil ist, dass es keine Sprachkonstrukte, sondern Objekte sind und können als solche in Feldern gespeichert und als Parameter an Methoden übergeben und aus Methoden zurückgegeben werden. Beispielsweise kann damit ein einzelnen Element ausgelesen werden und zu einem späteren Zeitpunkt an derselben Stelle fortgesetzt werden:</p>
<p><code>public boolean spieleHoerbuch(Iterator&lt;Book&gt; books, int zeit) {</code><br><code>    int gesamtzeit = 0;</code><br><code>    while (gesamtzeit &lt; zeit) {</code><br><code>        if (books.hasNext()) {</code><br><code>            Book book = books.next();</code><br><code>            gesamtzeit += book.getLaenge();</code><br><code>            spieleBook(book);</code><br><code>        } else {</code><br><code>            return false;</code><br><code>        }</code><br><code>    }</code><br><code>    return books.hasNext();</code><br><code>}</code></p>
<p>In diesem Beispiel werden solange Hörbücher abgespielt, bis eine Gesamtzeit erreicht ist, dann wird das aktuelle Hörbuch zu ende gespielt. Wenn Sie die Methode das nächste Mal aktivieren, dann übergeben Sie denselben Iterator und es geht mit dem nächsten Hörbuch weiter.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Java Collection Sets</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/java-collection-sets.html"/>
        <id>https://www.finecloud.ch/java-collection-sets.html</id>
            <category term="softwareentwicklung"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="collectionset"/>
            <category term="collection"/>
            <category term="array"/>

        <updated>2022-05-26T14:03:21+02:00</updated>
            <summary>
                <![CDATA[
                    Sets eignen sich für die Bearbeitung einer mathematischen Menge. Set kann somit keine identische Elemente enthalten und kann keine interneReihenfolge haben. Deshalb gibt es für Set auch keine Methoden die den direkten Zugriff auf ein Element ermöglichen. Um auf ein Element eines Set zuzugreifen muss&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Sets eignen sich für die Bearbeitung einer mathematischen Menge. Set kann somit keine identische Elemente enthalten und kann keine interneReihenfolge haben. Deshalb gibt es für Set auch keine Methoden die den direkten Zugriff auf ein Element ermöglichen. Um auf ein Element eines Set zuzugreifen muss darüber iteriert werden:</p>
<p><code>Set&lt;String&gt; besuchteOrte = new HashSet&lt;&gt;();</code><br><code>besuchteOrte.add("Bern");</code><br><code>besuchteOrte.add("Basel");</code><br><code>besuchteOrte.add("Bern");</code><br><code>besuchteOrte.add("Bellinzona");</code><br><code>for (String ort : besuchteOrte){</code><br><code>    System.out.println(ort);</code><br><code>}</code></p>
<p>Im Beispiel wird Bern nur einmal ausgegeben, auch wenn Bern zweimal hinzugefügt wurde, zählt es nur einmal. Beim Hinzufügen ein neuen Elementen mit der add-Methode, gibt die Collection einen boolean-Wert zurück: Wenn das Element hinzugefügt wurde, ist der return true, wenn der Wert bereits vorhanden war, false. So kann festgestellt werden, ob ein neues Element hinzugefügt wurde, oder nicht. Wichtig zu beachten ist zudem, dass die Ausgabe eines Collection Sets nicht in einer festgelegen Reihenfolge erfolgt und es auch keine konstante Reihenfolge der Werte in einem Collection Set gibt.</p>
<p>Die Hauptverwendung von Set, ist HashSet, das die Einmaligkeit der enthaltenen Elemente durch deren Hashcode sicherstellt. Wenn man also eine Set Collection verwenden, sollte man unbedingt in der Klasse die Methoden hashCode und equals überschreiben:</p>
<p><code>Set&lt;Book&gt; meineBuecher = new HashSet&lt;&gt;();</code><br><code>meineBuecher.add(new Book("Bretonische Nächte", "Jean-Luc Bannalec", 298));</code><br><code>meineBuecher.add(new Book("Bretonische Nächte", "Jean-Luc Bannalec", 316));</code></p>
<p>Wenn die Klasse Book die hashCode Methode nicht überschreibt, dann ist "Bretonische Nächte" zweimal im Set enthalten, denn die von Object geerbte bashCode-Implementierung gibt für verschiedene Objekte verschiedene Werte zurück, auch wenn die Objekte Inhaltsgleich sind. Deshalb muss eine eigene hashCode-Methode geschrieben werden, die den Code aus Titel, Autor und Seitenzahl berechnet, dann wird das zweite Buch nicht hinzugefügt, weil das Buch jetzt als identisch erkannt wird.</p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Java Collection Listen</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/java-collection-listen.html"/>
        <id>https://www.finecloud.ch/java-collection-listen.html</id>
            <category term="softwareentwicklung"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="collectionlist"/>
            <category term="collection"/>
            <category term="arraylist"/>
            <category term="array"/>

        <updated>2022-05-26T14:44:15+02:00</updated>
            <summary>
                <![CDATA[
                    Listen sind Collections, die am ehesten einem Array entsprechen. Die Elemente bleiben in der Reihenfolge wie sie hinzugefügt werden und sie können auf einzelne Positionen im Index der Liste zugreifen: lesen mit get(index) und schreiben mit set(index, element). Damit ist mit Listen alles möglich, was&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Listen sind Collections, die am ehesten einem Array entsprechen. Die Elemente bleiben in der Reihenfolge wie sie hinzugefügt werden und sie können auf einzelne Positionen im Index der Liste zugreifen: lesen mit <em>get(index) </em>und schreiben mit <em>set(index, element).</em></p>
<p>Damit ist mit Listen alles möglich, was man mit Arrays auch kann, einfach mit mehr Komfort. Die Liste wächst bei neuen Elementen automatisch an und wenn ein Element mit remove entfernt wird, wird die Lücke geschlossen, indem alle nachfolgenden Elemente nachrutschen:</p>
<p><code>List&lt;Book&gt; booklist = new ArrayList&lt;&gt;();</code><br><code>//Der Booklist zwei Books hinzufügen</code><br><code>booklist.add(new Book(…));</code><br><code>booklist.add(new Book(…));</code><br><code>//Das zweite Buch durch ein anderes ersetzen</code><br><code>booklist.set(1, new Book(…));</code><br><code>//Alle Buecher anzeigen</code><br><code>for (Book book : booklist){</code><br><code>    System.out.println(book.getTitel());</code><code></code><br><code>}</code></p>
<p>Für die meisten Fälle ist die ArrayList die performanteste aller List-Implementierungen.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Java Collections</title>
        <author>
            <name>Finecloud</name>
        </author>
        <link href="https://www.finecloud.ch/java-collections.html"/>
        <id>https://www.finecloud.ch/java-collections.html</id>
            <category term="softwareentwicklung"/>
            <category term="java"/>
            <category term="dev"/>
            <category term="collection"/>
            <category term="array"/>

        <updated>2022-05-26T13:27:11+02:00</updated>
            <summary>
                <![CDATA[
                    Collections sind ganz alltägliche Java Objekte. Im Gegensatz zu Arrays sind Collections nicht durch native Methoden und einem zusammenhängenden Speicherbereich optimiert, sie haben auch keine eigene Syntax. Die Vorteile von Collections sind der Benutzerkomfort, da sie über eine umfangreichere und komfortablere API verfügen. Zudem können&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Collections sind ganz alltägliche Java Objekte. Im Gegensatz zu Arrays sind Collections nicht durch native Methoden und einem zusammenhängenden Speicherbereich optimiert, sie haben auch keine eigene Syntax. </p>
<p>Die <strong>Vorteile von Collections</strong> sind der <strong>Benutzerkomfort</strong>, da sie über eine <strong>umfangreichere und komfortablere API</strong> verfügen. Zudem können verschiedene Implementierungen des Interface Collection, je nach Anwendungsfall verwendet werden. Der wohl grösste Vorteil, ist das Collections <strong>keine Grösse Vorgeben, Collections wachsen bei Bedarf.</strong></p>
<blockquote>
<p>Arrays eignen sich deshalb besondern für Performance getrimmte und Systemnahe Applikationen, während Collections eher für Anwendungen geeignet sind, bei denen es nicht auf jede Nanosekunde ankommt und der Vorteil des Komforts überwiegt.</p>
</blockquote>
<p>Standardmässig arbeiten Collections einfach mit dem Typ Object. Wenn man will, kann man einer Collection einen bestimmten Typ mitgeben:</p>
<p><code> Collection&lt;Buch&gt; playlist = new ArrayList&lt;&gt;();</code></p>
<p>Es gibt bei Collections keine Methoden für den Zugriff auf ein bestimmtes Element. Der allgemeine Ansatz, an den Inhalt einer Collection heranzukommen, ist der, sie in einer for-each-Schleife zu durchlaufen oder mit der Methode iterator ein Iterator-Objekt zu erzeugen. Nachfolgend sind die wichtigsten Methoden aufgelistet:</p>
<table style="border-collapse: collapse; width: 100%; height: 287.828px;" border="1">
<tbody>
<tr style="height: 50.3594px;">
<td style="width: 30.5463%; height: 50.3594px;"><strong>Methoden von <em>java.util.Collection</em></strong></td>
<td style="width: 69.4537%; height: 50.3594px;"><strong>Beschreibung</strong></td>
</tr>
<tr style="height: 107.953px;">
<td style="width: 30.5463%; height: 107.953px;">add / addAll</td>
<td style="width: 69.4537%; height: 107.953px;">Fügen einer Collection ein Objekt, bzw. alle Objekte einer anderen Collection hinzu.</td>
</tr>
<tr style="height: 79.1562px;">
<td style="width: 30.5463%; height: 79.1562px;">contains / containsAll</td>
<td style="width: 69.4537%; height: 79.1562px;">Prüfen, ob ein oder mehrere Objekte in der Collection enthalten sind.</td>
</tr>
<tr style="height: 50.3594px;">
<td style="width: 30.5463%; height: 50.3594px;">remove / removeAll</td>
<td style="width: 69.4537%; height: 50.3594px;">Entfernt Objekte aus der Collection</td>
</tr>
</tbody>
</table>
<p>Was wenn ich nun aber doch ein Array will? Dann kann ich mit der toArray-Methode jede Collection in ein Array umwandeln. Die parameterlose toArray-Methode liefert aber immer ein Object[], auch wenn ein Typ für die Collection angeben wurde. Es ist nicht möglich ein solches Object[] Array einfach in den gewünschten Typ zu casten. Wenn ich aber aus einer Collection von Buecher ein Buch[] machen will, dann muss ich die toArray-Methode mit Parameter übergeben:</p>
<p><code>Collection&lt;Double&gt; liste = new ArrayList&lt;&gt;();</code><br><code>Double[] alsDoubles = liste.toArray(new Double[liste.size()]);</code><br><code>Number[] alsNumber = liste.toArray(new Number[liste.size()]);</code><br><code>Object[] alsObject = liste.toArray(new Object[liste.size()]);</code><br><code>Object[] auchAlsObject = liste.toArray();</code></p>
<p>Wichtig ist, dass die Grösse des Arrays passt. Wenn das Array zu klein ist, dann ist der Rückgabewert ein neues Array des gleichen Typs mit der Grösse der Collection.</p>
            ]]>
        </content>
    </entry>
</feed>
