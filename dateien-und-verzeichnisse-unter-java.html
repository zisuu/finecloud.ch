<!DOCTYPE html><html lang="de-ch"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Dateien und Verzeichnisse unter Java - Finecloud</title><meta name="description" content="Dateioperationen mit java.io werden in Java immer, direkt oder indirekt, durch ein Objekt des Typs java.io.File abgebildet. Dabei kann File aber nicht selbst aus Dateien lesen, oder in sie schreiben, dazu benötigt man einen Reader oder Writer (für Textdateien) resp. einen InputStream oder OutputStream (für&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://www.finecloud.ch/dateien-und-verzeichnisse-unter-java.html"><link rel="alternate" type="application/atom+xml" href="https://www.finecloud.ch/feed.xml"><link rel="alternate" type="application/json" href="https://www.finecloud.ch/feed.json"><meta property="og:title" content="Dateien und Verzeichnisse unter Java"><meta property="og:site_name" content="Finecloud"><meta property="og:description" content="Dateioperationen mit java.io werden in Java immer, direkt oder indirekt, durch ein Objekt des Typs java.io.File abgebildet. Dabei kann File aber nicht selbst aus Dateien lesen, oder in sie schreiben, dazu benötigt man einen Reader oder Writer (für Textdateien) resp. einen InputStream oder OutputStream (für&hellip;"><meta property="og:url" content="https://www.finecloud.ch/dateien-und-verzeichnisse-unter-java.html"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://www.finecloud.ch/media/website/finecloud.png" type="image/png"><link rel="stylesheet" href="https://www.finecloud.ch/assets/css/style.css?v=7c7ed2e3e90182a09465f36ea7129616"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.finecloud.ch/dateien-und-verzeichnisse-unter-java.html"},"headline":"Dateien und Verzeichnisse unter Java","datePublished":"2022-06-04T15:42","dateModified":"2022-06-06T23:13","description":"Dateioperationen mit java.io werden in Java immer, direkt oder indirekt, durch ein Objekt des Typs java.io.File abgebildet. Dabei kann File aber nicht selbst aus Dateien lesen, oder in sie schreiben, dazu benötigt man einen Reader oder Writer (für Textdateien) resp. einen InputStream oder OutputStream (für&hellip;","author":{"@type":"Person","name":"Finecloud","url":"https://www.finecloud.ch/authors/finecloud/"},"publisher":{"@type":"Organization","name":"Finecloud"}}</script><meta name="google-site-verification" content="seFY9U12uiEq5U3_MyZiX6XWzk0AVFl9zITr2ZKsytY"></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://www.finecloud.ch/">Finecloud</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://www.finecloud.ch/" target="_self">Blog</a></li><li><a href="https://www.finecloud.ch/tags/" target="_self">Tags</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><form action="https://www.finecloud.ch/search.html" class="search__form"><input class="search__input js-search-input" type="search" name="q" placeholder="search..." aria-label="search..." autofocus="autofocus"></form><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://www.finecloud.ch/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://www.finecloud.ch/media/website/download.jpg" srcset="https://www.finecloud.ch/media/website/responsive/download-xs.jpg 300w, https://www.finecloud.ch/media/website/responsive/download-sm.jpg 480w, https://www.finecloud.ch/media/website/responsive/download-md.jpg 768w, https://www.finecloud.ch/media/website/responsive/download-lg.jpg 1024w, https://www.finecloud.ch/media/website/responsive/download-xl.jpg 1360w, https://www.finecloud.ch/media/website/responsive/download-2xl.jpg 1600w" sizes="100vw" loading="eager" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2022-06-04T15:42">Juni 4, 2022</time></div><h1>Dateien und Verzeichnisse unter Java</h1></div></header></div><div class="wrapper post__entry"><div class="post__toc"><h3>Table of Contents</h3><ul><li><a href="#mcetoc_1g4tdqg1s5n6">Dateien und Pfade</a></li><li><a href="#mcetoc_1g4tdqg1s5n7">Dateioperationen aus "Files"</a></li><li><a href="#mcetoc_1g4tdqg1s5n8">Verzeichnisse</a></li></ul></div><p>Dateioperationen mit java.io werden in Java immer, direkt oder indirekt, durch ein Objekt des Typs java.io.File abgebildet. Dabei kann File aber nicht selbst aus Dateien lesen, oder in sie schreiben, dazu benötigt man einen Reader oder Writer (für Textdateien) resp. einen InputStream oder OutputStream (für Binärdateien).</p><h3 id="mcetoc_1g4tdqg1s5n6">Dateien und Pfade</h3><p>Ein File wird immer aus einer Pfadangabe, entweder <em>absolut</em> oder <em>relativ</em> erzeugt. Absolut geht von einem Wurzelverzeichnis aus, zum Beispiel C:\ unter Windows, oder / unter Linux. Ein relativer Pfad bezieht sich dagegen auf das aktuelle Verzeichnis des Benutzers, normalerweise von dort aus woher das Programm aufgerufen wurde. Wenn die Datei unter dem angegebenen Pfad nicht existiert, wird auch keine entsprechende Datei unter dem definierten Pfad angelegt:</p><p><code>File windowsDatei = new File("C:\\home\\user\\text.txt");</code><br><code>File linuxDatei = new File("/home/user/text.txt");</code></p><p>Pfade werden also je nach OS unterschiedlich angegeben. Für Windows Pfade als Konstante sind effektiv zwei Doppel Backslashes zu verwenden! Solange die Pfadeingabe vom Benutzer selbst kommt, macht das keine Probleme. Wenn aber aus dem Programm heraus Dateipfade erzeugt werden müssen, dann müssen Sie auf diese Details acht geben. Das richtige Zeichen zum trennen von Verzeichnissen in einer Pfadangabe findet sich in der Konstanten File.separator. Damit lässt sich einen Pfad OS unabhängig erstellen: </p><p><code>File datei = new File(File.separator + "home" </code><br><code>    + File.separator + "user"</code><br><code>    + File.separator + "text.txt");</code></p><p>Unter Unix-basierten Systemen funktioniert dieser Code. Unter Windows bleibt das Problem mit dem Laufwerksbuchstaben. Dazu kann unabhängig vom OS, alle Wurzelverzeichnisse aufgelistet werden. Dazu kennt File die statische Methode listRoots. So lässt sich ein OS unabhängiger Code schreiben:</p><p><code>public File waehleWurzel(){</code><br><code>    File[] wurzeln = File.listRoots();</code><br><code>    if (wurzeln.length == 1){</code><br><code>        return wurzeln[0];</code><br><code>    } else {</code><br><code>        System. out.println("Bitte wählen Sie eine Wurzel");</code><br><code>        for (int i = 0; i &lt; wurzeln.length; i++){</code><br><code>            System.out.println(i + ": " + wurzeln[i]);</code><br><code>        }</code><br><code>        int index = liesZahl();</code><br><code>        return wurzeln[index];</code><br><code>    }</code><br><code>}</code></p><p>Doch das reicht immer noch nicht ganz, denn unter Windows kann es hier mehrere Einträge geben, je nachdem wieviele Laufwerke vorhanden sind (C:\, D:\ ...). In diesem Fall wird der Benutzer geben, ein Laufwerk auszuwählen. Anschliessend kann ein neues File-Objekt relativ zur ausgewählten Wurzel erzeugt werden, indem dies dem Konstruktor angegeben wird:</p><p><code>File wurzel = waehleWurzel();</code><br><code>File datei = new File(wurzel, "home"</code><br><code> + File.separator + "user"</code><br><code> + File.separator + "text.txt");</code></p><p>Ob eine Datei überhaupt existiert kann mit der Methode exists überprüft werden. Da ein File lediglich die objektorientierte Repräsentation eines Pfades ist, kann man Files erzeugen, ohne das diese Dateien bereits existieren. Falls keine Datei existiert kann eine neue Datei mit createNewFile oder mit mkdir ein Verzeichnis an der vom Pfad angegebenen Stelle angelegt werden. File liefert weitere Informationen über Dateien:</p><table style="border-collapse: collapse; width: 100%; height: 525.297px;" border="1"><tbody><tr style="height: 50.3594px;"><td style="width: 49.9288%; height: 50.3594px;"><strong>Methode</strong></td><td style="width: 49.9288%; height: 50.3594px;"><strong>Funktion</strong></td></tr><tr style="height: 107.953px;"><td style="width: 49.9288%; height: 107.953px;">isFile()</td><td style="width: 49.9288%; height: 107.953px;">Prüft, ob es sich bei der angegebenen File-Objekt um eine Datei handelt, (oder einen Ordner)</td></tr><tr style="height: 107.953px;"><td style="width: 49.9288%; height: 107.953px;">isDirectory()</td><td style="width: 49.9288%; height: 107.953px;">Prüft, ob es sich bei der angegebenen File-Objekt um einen Ordner handelt, (oder eine Datei)</td></tr><tr style="height: 50.3594px;"><td style="width: 49.9288%; height: 50.3594px;">canRead()</td><td style="width: 49.9288%; height: 50.3594px;">Prüft, ob der Benutzer Leserechte hat</td></tr><tr style="height: 79.1562px;"><td style="width: 49.9288%; height: 79.1562px;">canWrite()</td><td style="width: 49.9288%; height: 79.1562px;">Prüft, ob der Benutzer Schreibrechte hat</td></tr><tr><td style="width: 49.9288%;">canExectue()</td><td style="width: 49.9288%;">Prüft, ob der Benutzer Ausführungsrechte hat</td></tr><tr style="height: 79.1562px;"><td style="width: 49.9288%; height: 79.1562px;">getName()</td><td style="width: 49.9288%; height: 79.1562px;">Liefert den Namen der Datei, ohne vorangehende Pfadangabe</td></tr><tr style="height: 50.3594px;"><td style="width: 49.9288%; height: 50.3594px;">getParent()<br>getParentFile()</td><td style="width: 49.9288%; height: 50.3594px;">Liefert das übergeordnete Verzeichnis, entweder als String mit getParent oder als Objekt mit getParentFile</td></tr><tr><td style="width: 49.9288%;">lastModified()</td><td style="width: 49.9288%;">Liefert das letzte Änderungsdatum der Datei als long</td></tr><tr><td style="width: 49.9288%;">length()</td><td style="width: 49.9288%;">Liefert die Grösse der Datei in Byte als long</td></tr><tr><td style="width: 49.9288%;">delete</td><td style="width: 49.9288%;">eine Datei löschen</td></tr><tr><td style="width: 49.9288%;">renameTo</td><td style="width: 49.9288%;">eine Datei umbenennen</td></tr></tbody></table><p>java.io.File stellt jedoch keine Methoden zur Verfügung für das Kopieren oder verschieben von Dateien. Dazu gibt es aber seit Java 7 eine Hilfsklasse aus Files.</p><h3 id="mcetoc_1g4tdqg1s5n7">Dateioperationen aus "Files"</h3><p>Die Klasse Files ist eine Sammlung von Hilfsmethoden für alles, was mit Dateien zu tun hat. Diese Klasse ist aber nicht im java.io-Package enthalten, sondern nur im java.nio.files. Damit ist es die einzige Klasse aus der Non-Blocking-I/O-API, die man auch beim alltäglichen Umgang mit Dateien regelmässig benutzt.</p><p>Da die Hilfsklasse zu der API java.nio.file.Path gehört und nicht zur java.io.File müssen bei jeder Operation die Parameter von File nach Path und die Rückgabewerte, falls Dateien zurückgegeben werden, wieder von Path nach File konvertiert werden. Dabei lassen sich nicht alle Path-Objekte nach File konvertieren, nur solche welche aus einer Operation auf einem File resultieren. Damit sind auch Kopier- und Verschiebeoperationen möglich. Die Verwendung dieser Methode macht mehr Sinn, als eine Eigenentwicklung in Java, da dies nicht nur praktischer ist, sondern auch effizienter die JDL Systemaufrufe verwenden kann.</p><p><code>//File nach Path konvertieren</code><br><code>Path quellPath = quelle.toPath();</code><br><code>Path zielPath = ziel.toPath();</code><br><code>//ENTWEDER Datei kopieren</code><br><code>Path ergebnisPath = Files.copy(quellPath, zielPath);</code><br><code>//ODER Datei verschieben</code><br><code>Path ergebnisPath = Files.move(quellPath, zielPath);</code><br><code>//Ergebnis - eigentlich wieder das Ziel - nach File konvertieren</code><br><code>File ergebnis = ergebnisPath.toFile();</code></p><h3 id="mcetoc_1g4tdqg1s5n8">Verzeichnisse</h3><p>Um den Inhalt von Verzeichnissen zu ermitteln, gibt es die überladene Methode listFiles die zur Files Klasse gehört. Ohne Parameter gibt sie alle im Verzeichnis enthaltenen Dateien zurück. Wenn man nur an bestimmten Dateien interessiert ist, dann sollte man entweder einen FileFilter oder einen FilenameFilter an listFiles übergeben. Die beiden Filterklassen unterscheiden sich nur darin, dass FileFilter das File-Objekt der gefundenen Datei zur Prüfung erhält, FilenameFilter den Dateinamen als String und das aktuelle Verzeichnis. Beide Filter sind funktionale Interfaces und können deshalb auch als Lambdas angegeben werden.</p><p><code>//Alle Dateien auflisten</code><br><code>File[] alleDateien = verzeichnis.listFiles();</code><br><code>//Alle Dateien mit der Endung .txt auflisten </code><br><code>File[] textDateien = verzeichnis.listFiles((parent, name) -&gt; </code><br><code> name.endsWith(".txt"));</code><br><code>//Alle Unterverzeichnisse auflisten</code><br><code>File[] unterverzeichnisse = verzeichnis.listFiles(file -&gt; </code><br><code> file.isDirectory());</code></p><p>Auch zum Auflisten des Verzeichnisinhalts hat die Klasse Files Hilfsmethoden. list gibt dabei den Inhalt eines Verzeichnisses als einen Stream von Path-Objekten zurück. walk, listet nicht nur den Inhalt des übergebenen Verzeichnisses auf, sondern auch aller Unterverzeichnisse, ist also rekursiv.</p><p><code>Files.walk(quelle.toPath()).forEach(System.out::println);</code></p><p>Optional kann die Tiefe der rekursiven Auflistung limitiert werden bis zu einer bestimmten Tiefe. walk(quelle, 1) enthält nur den Inhalt des Verzeichnisses selbst, tut also dasselbe wie list. walk(quelle, 2) enthält den Inhalt der Verzeichnisses und seiner direkten Unterverzeichnisse usw.</p><p>Weiter kann mit Files.find in einem Verzeichnis und dessen Unterverzeichnisse nach Dateien gesucht werden, die bestimmten Vorgaben entsprechen. Leider ist auch hier dass java.io und java.nio nicht aus einem Guss. So muss man also die Suchkriterien nicht als FileFilter angeben, sondern als BiPredicate, das als Parameter des Path-Objekt der Datei und ein Objekt vom Typ BasicFileAttributes erhält, in dem sich Informationen wie Dateigrösse und letzte Zugriffszeit finden. Das Beispiel zeigt, wie man Dateien, die grösser als 500MB sind, auflisten kann. Der grosse Nachteil von walk und find ist, dass wenn der Zugriff auf ein Verzeichnis nicht möglich ist, brechen sie mit einer Fehlermeldung ab. Es gibt keine Funktion, diesen Methoden beizubringen, bei unlesbaren Verzeichnissen einfach den Fehler zu ignorieren und weiter zu suchen. Deswegen wird häufig dennoch auf File.listFiles zurückgegriffen.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on Juni 6, 2022</p><ul class="post__tag"><li><a href="https://www.finecloud.ch/tags/dev/">dev</a></li><li><a href="https://www.finecloud.ch/tags/java/">java</a></li><li><a href="https://www.finecloud.ch/tags/softwareentwicklung/">software development</a></li></ul><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://www.finecloud.ch/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://www.finecloud.ch/java-genereische-methoden-und-beschraenkte-typen.html" class="post__nav-link" rel="prev"><span>Previous</span> Genereische Java Methoden und beschränkte Typen</a></div><div class="post__nav-next"><a href="https://www.finecloud.ch/proxmox-ve-intro.html" class="post__nav-link" rel="next"><span>Next</span> Proxmox VE 7.2 Übersicht </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://www.finecloud.ch/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav><div class="post__related related"><div class="wrapper"><h2 class="h5 related__title">You should also read:</h2><article class="related__item"><div class="feed__meta"><time datetime="2022-05-26T14:07" class="feed__date">Mai 26, 2022</time></div><h3 class="h1"><a href="https://www.finecloud.ch/java-collection-iteratoren.html">Java Collection Iteratoren</a></h3></article><article class="related__item"><div class="feed__meta"><time datetime="2022-05-26T13:28" class="feed__date">Mai 26, 2022</time></div><h3 class="h1"><a href="https://www.finecloud.ch/java-collection-sets.html">Java Collection Sets</a></h3></article><article class="related__item"><div class="feed__meta"><time datetime="2022-05-26T13:19" class="feed__date">Mai 26, 2022</time></div><h3 class="h1"><a href="https://www.finecloud.ch/java-collection-listen.html">Java Collection Listen</a></h3></article></div></div></main><footer class="footer"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="https://www.finecloud.ch/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://www.finecloud.ch/assets/js/scripts.min.js?v=6ca8b60e6534a3888de1205e82df8528"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>